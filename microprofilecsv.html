<!DOCTYPE HTML>
<html>
<head>
<title>MicroProfile CSV viewer</title>
<style>
/* about css: http://bit.ly/1eMQ42U */
body {margin: 0px;padding: 0px; font: 12px Courier New;background-color:#343434; color:white;overflow:hidden;}
ul {list-style-type: none;margin: 0;padding: 0;}
li{display: inline; float:left;border:5px; position:relative;text-align:center;}
a {
    float:left;
    text-decoration:none;
    display: inline;
    text-align: center;
	padding:5px;
	padding-bottom:0px;
	padding-top:0px;
    color: #FFFFFF;
    background-color: #343434;
}
a:hover, a:active{
	background-color: #000000;
}

ul ul {
    position:absolute;
    left:0;
    top:100%;
    margin-left:-999em;
}
li:hover ul {
    margin-left:0;
    margin-right:0;
}
ul li ul{ display:block;float:none;width:100%;}
ul li ul li{ display:block;float:none;width:100%;}
li li a{ display:block;float:none;width:100%;text-align:left;}
#nav li:hover div {margin-left:0;}
.dropzone {display:flex;justify-content:center;align-items:center;font-size:50px;position: fixed; top: 0; left: 0; z-index: 9999999999; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);transition: visibility 175ms, opacity 175ms;}
.help {position:absolute;z-index:5;text-align:left;padding:2px;margin-left:-999em;background-color: #313131;width:300px;}
.helpstart {position:absolute;z-index:5;text-align:left;padding:2px;background-color: #313131;width:300px;display:none}
.root {z-index:1;position:absolute;top:0px;left:0px;}
.filterinputsearchdiv{position:fixed; background-color: #313131;display:none;}
.filterinputsearch{width:100px;}
</style>
</head>
<body style="">
<div style="visibility:hidden; opacity:0" class="dropzone" ondrop="DropHandler(event);" ondragover="DragOverHandler(event);">
Drop .csv file to view CSV data.<br>
Drop multiple .csv files to create a set and view min/max/average<br>
Include .mp4 file to show video<br>
Drop multiple sets of .csv/.mp4 files to compare averages/min/max<br>
<br>
h: Show help<br>
1-8: Toggle no. of graphs<br>
Mousewheel/Ctrl + mouse up/down: Zoom<br>
Left Mouse + mouse left/right: Pan<br>
Right Mouse + mouse left/right: Show Range info
Space: Toggle Set display<br>
</div>
<div class="filterinputsearchdiv" id="FilterInputDiv">Filter<br><input type="text" id="FilterInput" class="filterinputsearch"></div>
<div class="helpstart" id="helpwindow" style="left:20px;top:20px">
<table style="width:100%">
<tr>
<td width="50%" align="left"><a href='javascript:void(0)' onclick="ShowHelp(0);">Close</a></td>
</tr>
</table>
</div>
<canvas id="DetailedView" height="100%" style="background-color:#343434;margin:0px;padding:0px;"></canvas>
<script>
"use strict"

var FRAME_HISTORY_COLOR_CPU = '#ff7f27';
var FRAME_HISTORY_COLOR_GPU = '#ffffff';

var Settings = {};
var Cookie = {};

const PERCENTILE_SAMPLES = 1000;

var HistoryHeight = 100;
var CanvasDetailedView = document.getElementById('DetailedView');
var CanvasDetailedOffscreen = document.createElement('canvas');
var FilterInput = document.getElementById('FilterInput');
var FilterInputDiv = document.getElementById('FilterInputDiv');
var FilterInputDivPos = {"x":-1,"y":-1,"w":-1,"h":-1};
var FilterInputValueLast = '';

var CanvasArray0 = [];
var CanvasArray1 = [];
var Views = [];

var ViewIndex = 0;

var nWidth = CanvasDetailedView.width;
var nHeight = CanvasDetailedView.height;
var nBackColors = ['#292929', '#343434' ];
var nBackColorsDark = ['#292929', '#272727' ];
var nBackColorOffset = '#404040';
var FontHeight = 10;
var FontHeightLarge = 12;
var FontWidth = 1;
var FontAscent = 3; //Set manually
var Font = 'Bold ' + FontHeight + 'px Courier New';
var FontLarge = 'Bold ' + FontHeightLarge + 'px Courier New';
var FontFlash = 'Bold ' + 35 + 'px Courier New';
var BoxHeight = FontHeight + 2;
var MouseX = 0;
var MouseY = 0;
var MouseReleased = false;
var MouseMoveTime = new Date();

var nBarsWidth = 80;
var nOffsetBarsX = 0;
var nOffsetBarsY = 0;
var nOffsetCountersY = 0;
var nOffsetMenuTimers = 0;
var nOffsetMenuGroup = 0;
var nOffsetMenuFunctions = 0;
var nOffsetMenuModules = 0;
var nOffsetMenuPatched = 0;

var nHoverCounter = -1;

var MouseDragOff = 0;
var MouseDragDown = 1;
var MouseDragUp = 2;
var MouseDragMove = 3;
var MouseDragState = MouseDragOff;
var MouseDragTarget = 0;
var MouseDragButton = 0;
var MouseDragKeyShift = 0;
var MouseDragKeyCtrl = 0;
var MouseDragX = 0;
var MouseDragY = 0;
var MouseDragXLast = 0;
var MouseDragYLast = 0;
var MouseDragXStart = 0;
var MouseDragYStart = 0;

var MouseDragActiveXStart = 0;
var MouseDragActiveXEnd = -1;
var MouseInCaptureButton = 0;

var ToolTipCallback = null;
let ToolTipImmediate = null;
let ToolTipTag = null;
let ToolTipImmediateColumns = 2;


var DPR = 0;
var C_HUGE = 1e10;

var ActivePreset = "Default";
var ActivePresetRO = 0;
var PresetPending = 0;
var Presets = [];
var PresetsCache = {};
var ReadOnlyPresets = [];
var ReadOnlyPresetsCache = {};

Settings.SubGraphSettings = {};
Settings.ReferenceTime = 50.0;
var ReferencePresets = [5.0, 10.0, 15.0, 20, 30, 33.33, 50, 66.66,100.0,250.0,500,1000.0];
var PercentilePresets = [0.0, 1.0, 5.0, 10.0, 50.0, 75.0, 99.0];
var ReferenceTimeTweak = -1;
var PercentileTweak = -1;

Settings.TargetTime = 30;
var TargetTimeTweak = -1;



let LastDropTarget = null;


// Begin shared: internal profiling
var ProfileData = {};
var ProfileStackTime = [];
let ProfileStackName = [];
var ProfileMode = 0;
var ProfileRedraw0 = 0;
var ProfileRedraw1 = 0;
var ProfileRedraw2 = 0;
var ProfileFps = 0;
var ProfileMs = 0;
var ProfileFpsAggr = 0;
var ProfileFpsCount = 0;
var ProfileLastTimeStamp = new Date();
function CreateEmptyFloatArray(Size)
{
	let a = Array(Size);
	for(let i = 0; i < Size; ++i)
		a[i] = 0.0;
	return a;
}
function FormatNumber(f, digits)
{
	if(digits >= 0)
		 return f.toFixed(digits);
	else
		return f + "";
}
// End shared: internal profiling


var PlotfArray = new Array();



var ConnectionStr = ["\\", "|", "/", "-" ];
var ConnectionIdx = 0;
var EnabledArray = [];


var FrameData = {};
var FRAME_COUNT = 256;
var FramePending = 0;

var WSConnected = 0;
var WSIsOpen = 0;
var WSSeconds = 0;
var WSFail = 0;
var WS;
var WSHost = location.hostname ? location.hostname : "localhost";
var WSPort = location.port ? location.port : 1338;
var WSPath;

var CaptureButtonX = 0;
var CaptureButtonY = 0;
var GroupsEnabled = 0;
var TimersEnabled = 0;

var TimersActiveOnly = 0;


var MSG_TIMER_TREE = 1;
var MSG_ENABLED = 2;
var MSG_FRAME = 3;
var MSG_LOADSETTINGS = 4;
var MSG_PRESETS = 5;
var MSG_CURRENTSETTINGS = 6;
var MSG_COUNTERS = 7;
var MSG_FUNCTION_RESULTS = 8;
var MSG_INACTIVE_FRAME = 9;
var MSG_FUNCTION_NAMES = 10;
var MSG_INSTRUMENT_ERROR = 11;
// var MSG_MODULE_NAME = 12;


var TYPE_NONE = 0;
var TYPE_TIMER = 1;
var TYPE_GROUP = 2;
var TYPE_CATEGORY = 3;
var TYPE_SETTING = 4;
var TYPE_COUNTER = 5;


var WSSend = 0;
var WSReceive = 0;
var WSSendBytes = 0;
var WSReceiveBytes = 0;
var WSOpenTime = 0;


var TimerArray = [];
var CounterArray = [];
var Empty = {"id":0, "w":0, "depth":0, "sibling":-1,"parent":-1,"firstchild":-1};
var WidthArray = [];
var FunctionQueryArray = [];
var FunctionQueryPending = null;
var FunctionQueryLastRequest = 0;
var FunctionQueryReceived = 0;
var WidthTree = 0;
Settings.ViewActive = 0;
Settings.ViewCompressed = 0;
Settings.AllowHighDPI = 1;
var ViewNames = ["Graph", "Graph", "Graph", "Bars", "Bars", "Bars", "Counters", "CSV Data"];
var ViewNames2 = ["[split]", "[percentile]","[group/thread]","[table]", "[all]", "[single]", "", ""];

var VIEW_GRAPH_SPLIT = 0;
// var VIEW_GRAPH = 1;
var VIEW_GRAPH_PERCENTILE = 1;
var VIEW_GRAPH_THREAD_GROUP = 2;
var VIEW_BAR = 3;
var VIEW_BAR_ALL = 4;
var VIEW_BAR_SINGLE = 5;
var VIEW_COUNTERS = 6;
var VIEW_CSV = 7;
var VIEW_SIZE = 8;

var GRAPH_ALPHA = 0.5;


Settings.AutomaticReference = 1;
Cookie.CodeReportMode = 0; // 0: prompt, 1:always send, 2: never send, never prompt


var ReferenceHistory = 0;
var ReferenceGraph = 0;
var ReferenceBar = 0;
var ReferenceHistoryAutomatic = 0;
var ReferenceGraphAutomatic = 0;
var ReferenceGraphAutomaticGroup = 0;
var ReferenceBarAutomatic = 0;

var SingleTimerBars = 0;
var History;
var MainView;
let CSVView;

var ViewBarMaxMsTextLength = 0;

Settings.SortColumnOrderFlip = 0;
Settings.SortColumnName = "";
var SortColumnMouseOverNext = "";


var KeyShiftDown = 0;
var KeyCtrlDown = 0;
var KeyHDown = 0;
let KeyZDown = 0;

var IsFrozen = 0;

var PresetToLoad;
var PresetToLoadRO = 0;
var HelpFade;

let gRange = 1;
let gOffset = 0;
let gRangeMaxLen = 1;
let gGraphCSVInvalid = 1;

// CSV Data
let CSVSets = {};
let CSVAllColumns = {};
let CSVIndex = 0;
let CSVMaxLength = 0;
let CSVNumSets = 0;
let CSVSetNames = [];
let CSVActiveSet = 0;

let gDrawFrame = 1;

let MAX_GRAPHS = 8;
let MAX_PRESETS = 10;
let DEFAULT_GRAPH_MODE_MASK = 1 | 2;
let PresetSets = {};
let PresetNamed = {};
let GraphPresetIndex = 0;
let NumGrap = null;



let MouseInGraphButton = 0;
let MouseInGraphModeButton = 0;

let GraphButtonIndex = -1;
let GraphModeButtonIndex = 0;

let GraphButtonX = 0;
let GraphButtonY = 0;

let GraphModeButtonX = 0;
let GraphModeButtonY = 0;

let RangeSelect = RangeInit();
let RangeSelectState = RangeInit();

let RangeToolTipColumns = 4;
let RangeToolTips = new Array(MAX_GRAPHS);


for(let i = 0; i < MAX_GRAPHS; ++i)
{
	RangeToolTips[i] = {};
}

const VideoTrackHeight = 200;
let VideoTrackHeightActive = 200;
const AllowTime = 1;
let gMouseXPrc = 0;
let gMouseIndex = 0;

function AddNamedPreset(Name, Settings)
{
	PresetNamed[Name] = JSON.parse(Settings);
}

/// --insert named presets here--

function CreateDefaultGraphSettings()
{
	let GraphSettings = {};
	GraphSettings.Graphs = new Array(MAX_GRAPHS);
	for(let i = 0; i < MAX_GRAPHS; ++i)
	{
		GraphSettings.Graphs[i] = {};
	}
	GraphSettings.NumGraphs = MAX_GRAPHS;
	GraphSettings.GraphModeMask = DEFAULT_GRAPH_MODE_MASK;
	return GraphSettings;
}

let GraphSettings = CreateDefaultGraphSettings();

PresetSets[0] = GraphSettings;


TimerArray.push(Empty); // 0 is root of tree

let CounterNameWidth = 100;
let CounterValueWidth = 100;
let CounterLimitWidth = 100;

let FormatCounterDefault = 0;
let FormatCounterBytes = 1;
let FormatCounterBytesExt = ["b","kb","mb","gb","tb","pb","eb","zb","yb"];



function ConvertHslToRGB(h, s, l) //from https://gist.github.com/mjackson/5311256
{
	let r, g, b;
	if (s == 0)
	{
		r = g = b = l; // achromatic
	}
	else
	{
		function hue2rgb(p, q, t)
		{
			if (t < 0) t += 1;
			if (t > 1) t -= 1;
			if (t < 1/6) return p + (q - p) * 6 * t;
			if (t < 1/2) return q;
			if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
			return p;
		}
		let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		let p = 2 * l - q;
		r = hue2rgb(p, q, h + 1/3);
		g = hue2rgb(p, q, h);
		b = hue2rgb(p, q, h - 1/3);
	}
	let color = ((r*255)<<16) | ((g*255)<<8) | (b*255);
	return ("000000" + color.toString(16)).slice(-6);
}

function RangeInit()
{
	return {"Begin":-1, "End":-1, "YBegin":-1, "YEnd":-1, "Thread": -1 , "Index": -1, "Off": 0, "Second":0};
}

RangeSelect = RangeInit();

function RangeValid(Range)
{
	return Range.Begin < Range.End;
}

function RangeInvalidate(Range)
{
	Range.Begin = -1;
	Range.End = -1;
}

function RangeCopy(Dst, Src)
{
	Dst.Begin = Src.Begin;
	Dst.End = Src.End;
	Dst.YBegin = Src.YBegin;
	Dst.YEnd = Src.YEnd;
	Dst.Thread = Src.Thread;
	Dst.Off = Src.Off;
	Dst.Second = Src.Second;
}



function Plotf(str)
{
	PlotfArray.push(str);
}
function PlotfClear()
{
	PlotfArray = new Array();
}



function ProfileModeClear()
{
	if(ProfileMode)
	{
		for(var idx in ProfileData)
		{
			if(idx == "Plot")
				continue;
			var Timer = ProfileData[idx];
			Timer.Count = 0;
			Timer.Time = 0;
		}
		ProfileStackTime = new Array();
		ProfileStackName = new Array();

		RequestDraw();
	}
}
function ProfileEnter(Name, Graph)
{
	if(ProfileMode)
	{
		ProfileStackTime.push(performance.now());
		ProfileStackName.push(Name);
		var Obj = ProfileData[Name];
		if(!Obj)
		{
			Obj = new Object();
			Obj.Count = 0;
			Obj.Name = Name;
			Obj.Time = 0;
			Obj.AggrCount = 0;
			Obj.AggrTime = 0;
			Obj.AggrMax = 0;
			Obj.AvgTime = 0;
			Obj.MaxTime = 0;
			Obj.TotalTime = 0;
			Obj.Graph = Graph;
			Obj.GraphData = CreateEmptyFloatArray(120);
			ProfileData[Name] = Obj;
		}
	}
}
function ProfileLeave()
{
	if(ProfileMode)
	{
		let Time = performance.now();
		let Delta = Time - ProfileStackTime.pop();
		let Name = ProfileStackName.pop();
		let Obj = ProfileData[Name];
		if(Obj)
		{
			Obj.Time += Delta;
			Obj.Count += 1;
		}
	}
}

function ProfilePlot(s)
{
	if(ProfileMode)
	{
		var A = ProfileData.Plot;
		if(!A)
		{
			ProfileData.Plot = Array();
			A = ProfileData.Plot;
		}
		if(A.length<10)
		{
			A.push(s);
		}
	}
}
function ProfileModeDump()
{
	for(var idx in ProfileData)
	{
		var Timer = ProfileData[idx];
		console.log(Timer.Name + " " + Timer.Time + "ms " + Timer.Count);
	}

}
function ProfileModeDraw(Canvas)
{
	if(ProfileMode)
	{
		ProfileFpsCount ++ ;
		var AggrFrames = 60;
		var StringArray = [];
		function FormatTime(f)
		{
			return ("             " + f.toFixed(2)).slice(-12);
		}
		function FormatStr(t, count, avg, max, total)
		{
			var str = FormatTime(t) + "ms " + ("        #" + count).slice(-8) +
			"" + FormatTime(avg) + "ms " + FormatTime(max) + "ms " + FormatTime(total) + "ms";
			return str;
		}
		StringArray.push("");
		StringArray.push("time    count         avg            max       total/" +  AggrFrames + "  ");

		for(var idx in ProfileData)
		{
			if(idx == "Plot")
				continue;
			var Timer = ProfileData[idx];
			Timer.AggrCount += Timer.Count;
			Timer.AggrTime += Timer.Time;
			Timer.AggrMax = Math.max(Timer.AggrMax, Timer.Time);
			if(ProfileFpsCount == AggrFrames)
			{
				Timer.AvgTime = Timer.AggrTime / AggrFrames;
				Timer.MaxTime = Timer.AggrMax;
				Timer.TotalTime = Timer.AggrTime;
				Timer.AggrCount = 0;
				Timer.AggrTime = 0;
				Timer.AggrMax = 0;
			}
			PushIntoArray(Timer.GraphData, Timer.Time);
			StringArray.push(Timer.Name);
			StringArray.push(FormatStr(Timer.Time, Timer.Count, Timer.AvgTime, Timer.MaxTime, Timer.TotalTime));
		}
		var Time = new Date();
		var Delta = Time - ProfileLastTimeStamp;
		ProfileLastTimeStamp = Time;
		StringArray.push("Frame Delta");
		StringArray.push(Delta + "ms");
		{
			ProfileFpsAggr += Delta;

			if(ProfileFpsCount == AggrFrames)
			{
				ProfileMs = ProfileFpsAggr / AggrFrames;
				ProfileFps = 1000 / (ProfileFpsAggr / AggrFrames);
				ProfileFpsAggr = 0;
				ProfileFpsCount = 0;
			}
			StringArray.push("Avg FPS");
			StringArray.push("" + ProfileFps.toFixed(2));
			StringArray.push("Avg MS");
			StringArray.push("" + ProfileMs.toFixed(2));
		}
		for(var i = 0; i < ProfileData.Plot; ++i)
		{
			StringArray.push("");
			StringArray.push(ProfileData.Plot[i]);
		}
		ProfileData.Plot = Array();
		DrawToolTip(StringArray, Canvas, 0, 200);

		let Offset = 0;
		let Params = CreateDrawGraph2Parameters();
		Params.Digits = 2;
		var context = Canvas.getContext("2d");
		for(let idx in ProfileData)
		{
			if(idx == "Plot")
				continue;
			let Timer = ProfileData[idx];
			if(Timer.Graph)
			{
				let Mouse = {};
				Mouse.X = MouseX;
				Mouse.Y = MouseY;
				let GraphData = CreateGraph2Data(Timer.GraphData, Timer.Name, ColorFromString(Timer.Name, 75, 65));

				Params.Rect = WindowRect(Offset, nHeight-200, 200, 200);
	 			DrawGraph2(context, Params, [GraphData], Mouse);
	 			Offset += 201;
			}
		}
	}
}



function MeasureFont()
{
	var context = CanvasDetailedView.getContext('2d');
	context.font = Font;
	FontWidth = context.measureText('W').width;

}
function ResizeCanvasDPR(w, h, c)
{
	DPR = Settings.AllowHighDPI ? window.devicePixelRatio : 0;
	if(DPR)
	{
		c.style.width = w + 'px';
		c.style.height = h + 'px';
		c.width = w * DPR;
		c.height = h * DPR;
		c.getContext('2d').scale(DPR,DPR);
	}
	else
	{
		DPR = 1;
		c.width = w;
		c.height = h;
	}

}

function ResizeCanvasDPR2(w, h, c)
{
	DPR = window.devicePixelRatio;
	if(DPR)
	{
		c.style.width = w + 'px';
		c.style.height = h + 'px';
		c.width = w * DPR;
		c.height = h * DPR;
		c.getContext('2d').scale(DPR,DPR);
	}
	else
	{
		c.width = w;
		c.height = h;
	}

}
function ResizeView(View, x, y, w, h)
{
	View.x = x;
	View.y = y;
	View.w = w;
	View.h = h;
	var c0 = View.Canvas[0];
	var c1 = View.Canvas[1];
	ResizeCanvasDPR(w, h, c0);
	ResizeCanvasDPR(w, h, c1);
	c0.getContext('2d').clearRect(0, 0, w, h);
	c1.getContext('2d').clearRect(0, 0, w, h);
	View.OffscreenData[0] = c0.getContext('2d').getImageData(0, 0, c0.width, c0.height);
	View.OffscreenData[1] = c1.getContext('2d').getImageData(0, 0, c1.width, c1.height);

	gGraphCSVInvalid = 1;
	RequestDraw();

}
function CreateView(x, y, w, h, name, DisplayFunc,  visible, index, InvalidFunc)
{
	var idx = Views.length;
	var c0 = CanvasArray0[idx];
	var c1 = CanvasArray1[idx];

	if(!c0)
	{
		c0 = document.createElement('canvas');
		CanvasArray0[idx] = c0;
	}
	if(!c1)
	{
		c1 = document.createElement('canvas');
		CanvasArray1[idx] = c1;
	}
	var View = {};
	View.x = x;
	View.y = y;
	View.w = w;
	View.h = h;
	View.Canvas = [c0, c1];
	View.OffscreenData = [null, null];
	View.visible = visible;
	View.index = index;
	ResizeCanvasDPR(w, h, c0);
	ResizeCanvasDPR(w, h, c1);

	c0.getContext('2d').clearRect(0, 0, w, h);
	c1.getContext('2d').clearRect(0, 0, w, h);
	View.OffscreenData[0] = c0.getContext('2d').getImageData(0, 0, c0.width, c0.height);
	View.OffscreenData[1] = c1.getContext('2d').getImageData(0, 0, c1.width, c1.height);
	View.BackBuffer = 0;
	View.DisplayFunc = DisplayFunc;
	if(InvalidFunc)
		View.InvalidFunc = InvalidFunc;
	else
		View.InvalidFunc = function(){ return true; } ;
	Views.push(View);
	return View;
}

function CreateViews(Width, Height, ViewCompressed)
{
	Views = [];
	MainView = CreateView(0, 0, Width, Height, "Main", DrawGraphSplit, true);

	CSVView = CreateView(0, 0, Width, Height, "CSV", DrawGraphCSV, false, 0, InvalidGraphCSV);


}

function ResizeCanvas()
{
	nWidth = window.innerWidth;
	nHeight = window.innerHeight;
	DPR = Settings.AllowHighDPI ? window.devicePixelRatio : 0;
	ResizeCanvasDPR(nWidth, nHeight, CanvasDetailedView);
	ResizeCanvasDPR(nWidth, nHeight, CanvasDetailedOffscreen);

	if(DPR)
	{
		CanvasDetailedView.style.width = nWidth + 'px';
		CanvasDetailedView.style.height = nHeight + 'px';
		CanvasDetailedView.width = nWidth * DPR;
		CanvasDetailedView.height = nHeight * DPR;
		CanvasDetailedView.getContext('2d').scale(DPR,DPR);

		CanvasDetailedOffscreen.style.width = nWidth + 'px';
		CanvasDetailedOffscreen.style.height = nHeight + 'px';
		CanvasDetailedOffscreen.width = nWidth * DPR;
		CanvasDetailedOffscreen.height = nHeight * DPR;
		CanvasDetailedOffscreen.getContext('2d').scale(DPR,DPR);

	}
	else
	{
		DPR = 1;
		CanvasDetailedView.width = nWidth;
		CanvasDetailedView.height = nHeight;
		CanvasDetailedOffscreen.width = nWidth;
		CanvasDetailedOffscreen.height = nHeight;
	}
	MeasureFont();
	CreateViews(nWidth, nHeight, Settings.ViewCompressed);
	ActivateView(Settings.ViewActive);
	gGraphCSVInvalid = 1;
	RequestDraw();
}


function FormatTime(Time)
{
	return Time.toFixed(2);
}


function DrawGraphSplit(View, LocalMouseX, LocalMouseY, SubIndex)
{

}

function InvalidGraphCSV(View, LocalMouseX, LocalMouseY, SubIndex)
{
	return gGraphCSVInvalid;
}


function GraphCSVParameters(FullUpdate, View, LocalMouseX, LocalMouseY)
{
	let h = View.h;
	let w = View.w;


	let Params = CreateDrawGraph2Parameters();
	Params.Ext = "";
	Params.Digits = 5;
	Params.Rect = WindowRect(0, 0, w, h);
	Params.xRange = gRange;
	Params.xOffset = gOffset;
	Params.FullDraw = FullUpdate;
	Params.Frame = gDrawFrame ? 1 : 0;
	return Params;
}

function DrawGraphCSV(FullUpdate, View, Canvas, context, LocalMouseX, LocalMouseY, SubIndex)
{
	ProfileEnter("DrawGraphCSV", 1);
	if(FullUpdate)
	{
		context.clearRect(0, 0, View.w, View.h);
		gGraphCSVInvalid = 0;
	}


	let h = View.h;
	let w = View.w;
	let SingleGraph = 0;
	let SingleGraphHeight = VideoTrackHeight;
	let SingleGraphIndex = -1;
	let GraphHeight = h / GraphSettings.NumGraphs;

	let Params = GraphCSVParameters(FullUpdate, View, LocalMouseX, LocalMouseY);
	let Mouse = {};

	let NumGraphs = GraphSettings.NumGraphs;
	let Graphs = GraphSettings.Graphs;


	if(HasVideoTrack())
	{
		h -= VideoTrackHeight;
		GraphHeight = h / GraphSettings.NumGraphs;

		if(KeyZDown)
		{
			//graph/video is swapped, and only one graph is shown
			NumGraphs = 1;
			Graphs = Array();
			let Index = Math.floor(LocalMouseY / GraphHeight);
			Graphs[0] = GraphSettings.Graphs[Index];
			let NewHeight = nHeight - VideoTrackHeightActive;
			LocalMouseY -= Index * GraphHeight;
			LocalMouseY = NewHeight * LocalMouseY / GraphHeight
			Params.MouseMarker = 1;
			GraphHeight = NewHeight;
		}
	}




	Mouse.X = LocalMouseX;
	Mouse.Y = LocalMouseY;

	gMouseXPrc = Graph2MouseXPrc(Params, Mouse) * Params.xRange + Params.xOffset;

	Params.IndexDesc = function(Index)
	{
		let Str = Index + '';
		for(let SetName in CSVSets)
		{
			let Set = CSVSets[SetName];
			if(Set.TimeData)
			{
				Index = Math.min(Index, Set.TimeData.length-1);
				let seconds = Set.TimeData[Index];
				Str += ": " + FormatSeconds(seconds);
			}

		}
		return Str;

	}



	let y = 0;
	let SetColors = 0;
	for(let set in CSVSets)
		SetColors++;
	if(SetColors < 2)
		SetColors = 0;


	let SetHueBase = [0.04, 0.30, 0.56];
	let SetHueRange = [0.16, 0.15, 0.15];
	let SetS = 96;
	let SetV = 98;
	let SetL = 50;
	let MouseIndex = -1;
	let SelectedGraphColumns;

	let UpdateRangeTooltip = RangeValid(RangeSelect) && (RangeSelect.Begin != RangeSelectState.Begin || RangeSelect.End != RangeSelectState.End);
	if(UpdateRangeTooltip)
	{
		RangeSelectState.Begin = RangeSelect.Begin;
		RangeSelectState.End = RangeSelect.End;
	}

	let InitToolTip = function()
	{
		let tt = {};
		let a = new Array();
		let c = new Array();
		tt.a = a;
		tt.c = c;
		a.push("");
		a.push("Average");
		a.push("Min");
		a.push("Max");
		return tt;
	};
	let ToolTipAdd = function(tt, Name, Color, Avg, Min, Max)
	{
		tt.c[tt.a.length] = Color;
		tt.a.push(Name);
		tt.a.push(FormatNumber(Avg, Params.Digits));
		tt.a.push(FormatNumber(Min, Params.Digits));
		tt.a.push(FormatNumber(Max, Params.Digits));


	};

	let ToolTipAddRange = function(tt, Name, Color, Avg_, Min_, Max_)
	{
		let Sum = 0;
		let AvgSamples = Avg_.Samples;
		let MinSamples = Min_.Samples;
		let MaxSamples = Max_.Samples;
		let Begin = Math.floor( 0.5 + RangeSelect.Begin);
		let End = Math.floor(0.5 + RangeSelect.End);
		let Min = MinSamples[Begin];
		let Max = MaxSamples[Begin];
		for(let i = Begin; i < End; ++i)
		{
			Min = Math.min(MinSamples[i], Min);
			Max = Math.max(MaxSamples[i], Max);
			Sum += AvgSamples[i];
		}
		let Avg = Sum / (End - Begin);
		ToolTipAdd(tt, Name, Color, Avg, Min, Max);
	};

	let ttt = 0;

	for(let i = 0; i < NumGraphs; ++i)
	{
		Params.Rect = WindowRect(0, y, w, GraphHeight);
		let Data = [];
		let GraphColumns = Graphs[i];
		let GraphMode = GraphSettings.GraphModeMask;

		if(UpdateRangeTooltip)
			RangeToolTips[i] = InitToolTip();

		for(let SetIndex = 0; SetIndex < CSVSetNames.length; ++SetIndex)
		{
			if(SetIndex == (CSVActiveSet-1) || CSVActiveSet == 0)
			{
				let SetName = CSVSetNames[SetIndex];
				let Set = CSVSets[SetName];
				if(!Set.Ready)
					continue;
				let ColumnIndex = 0;
				for(let ColumnName in GraphColumns)
				{

					if(GraphColumns[ColumnName] == 1 && Set.ColumnNames[ColumnName])
					{
						let ColumnPrc = (ColumnIndex % 5) / 4.0;
						let h = (SetHueBase[SetIndex%3] + SetHueRange[SetIndex%3] * ColumnPrc) * 360;
						let color = "hsl(" + h + "," + SetS + "%," + SetL + "%)";
						for(let j = 0; j < 8; ++j)
						{
							if(0 != (GraphMode &(1<<j)))
							{
								let src = null;
								if(j == 0)
									src = Set.GraphDataSect[ColumnName];
								else if(j == 1)
									src = Set.GraphDataAvg[ColumnName];
								else if(j == 2)
									src = Set.GraphDataMin[ColumnName];
								else if(j == 3)
									src = Set.GraphDataMax[ColumnName];
								else if(j == 4)
									src = Set.GraphDataPercentileSect[ColumnName];
								else if(j == 5)
									src = Set.GraphDataPercentileAvg[ColumnName];
								else if(j == 6)
									src = Set.GraphDataPercentileMin[ColumnName];
								else if(j == 7)
									src = Set.GraphDataPercentileMax[ColumnName];
								if(SetColors)
								{
									src.Color = color;
								}
								Data.push(src);
							}
						}
						ColumnIndex++;
						if(!SetColors)
							color = Set.GraphDataAvg[ColumnName].Color;

						if(UpdateRangeTooltip)
						{
							let t0 = performance.now();
							ToolTipAddRange(RangeToolTips[i], ColumnName, color, Set.GraphDataAvg[ColumnName], Set.GraphDataMin[ColumnName], Set.GraphDataMax[ColumnName]);
							let t1 = performance.now();
							ttt += (t1-t0);
						}
					}
				}
			}
		}

		let LocalMouseIndex = DrawGraph2(context, Params, Data, Mouse);
		if(LocalMouseIndex >= 0)
		{
			MouseIndex = LocalMouseIndex;
			gMouseIndex = MouseIndex;
			SelectedGraphColumns = GraphColumns;
		}
		y += GraphHeight;
	}

	if(!FullUpdate)
	{
		let Offset = 0;
		let UpdateRangeTooltip = false;

		if(RangeValid(RangeSelect))
		{
			Params.FormatIndex = function(Value)
			{
				Value = Math.round(Value);
				let r = Array();
				r.push('' + Value);
				let time = GetTimeFromIndexArray(Value);
				if(time.length)
				{
					r.push('');
					for(let i = 0; i < time.length; ++i)
						r.push(FormatSeconds(time[i]));
				}
				return r;
			};
			Params.FormatRange = function(Begin, End)
			{
				Begin = Math.round(Begin);
				End = Math.round(End);
				let r = Array();
				r.push('' + (End - Begin));
				let t0 = GetTimeFromIndexArray(Begin);
				let t1 = GetTimeFromIndexArray(End);
				let l = Math.min(t0.length, t1.length);
				if(l > 0)
				{
					r.push('');
					for(let i = 0; i < l; ++i)
						r.push(FormatSeconds(t1[i]-t0[i]));
				}
				return r;
			};

			Offset = DrawGraph2Range(context, Params, RangeSelect, "Selection", Offset);
		}

		if(MouseIndex >= 0)
		{

			ToolTipImmediateColumns = 4;
			ToolTipImmediate = InitToolTip();
            ToolTipTag = null;
			for(let SetIndex = 0; SetIndex < CSVSetNames.length; ++SetIndex)
			{
				if(SetIndex == (CSVActiveSet-1) || CSVActiveSet == 0)
				{
					let SetName = CSVSetNames[SetIndex];
					let Set = CSVSets[SetName];
					if(!Set.Ready)
						continue;
					for(let ColumnName in SelectedGraphColumns)
					{
						if(SelectedGraphColumns[ColumnName] == 1 && Set.ColumnNames[ColumnName])
						{
							ToolTipAdd(ToolTipImmediate, ColumnName,  Set.GraphDataAvg[ColumnName].Color, Set.GraphDataAvg[ColumnName].Samples[MouseIndex], Set.GraphDataMin[ColumnName].Samples[MouseIndex], Set.GraphDataMax[ColumnName].Samples[MouseIndex]);
						}
					}
                    if(Set.Tags[MouseIndex] != null)
                    {
                        if(!ToolTipTag)
                            ToolTipTag = new Array();
                        ToolTipTag.push(Set.Tags[MouseIndex]);
                    }
				}
			}
		}
	}


	ProfileLeave();

}



function StringHash(s) //note: matching code in microprofile.cpp: uint32_t MicroProfileStringHash(const char* pString)
{
	var h = 0xfeedba3e;
    for(var x = 0; x < 3; ++x)
	for(var i = 0; i < s.length; ++i)
	{
		h = s.charCodeAt(i) + ((h << 5) - h);
		h = h & h;
	}
	return Math.abs(h);
}

function StringColorIndex(Name)
{
	let h = StringHash(Name);
    let the_float = h  / (1<<32-1);
    let scaled = Math.abs(360.0 * the_float);
	let cidx = Math.floor(scaled);
	return cidx;
}

function ColorFromString(Name, S, L)
{
	var H = StringColorIndex(Name);
	return "hsl(" + H + "," + S + "%, " + L+ "%)";
}

function LerpColor(v)
{
	var R_0 = 0;
	var G_0 = 1;
	var B_0 = 0;

	var R_1 = 1;
	var G_1 = 0.5;
	var B_1 = 0;

	var R_2 = 1;
	var G_2 = 0;
	var B_3 = 0;
	var R;
	var G;
	if(v < 0.5)
	{
		v *= 2;
		var v0 = (1-v);
		R = R_0 * v0 + R_1 * v;
		G = G_0 * v0 + G_1 * v;

	}
	else
	{
		v = (v-0.5) * 2;
		var v0 = (1-v);
		R = R_1 * v0 + R_2 * v;
		G = G_1 * v0 + G_2 * v;
	}
	R *= 255;
	G *= 255;
	return "rgb(" + R.toFixed(0) + "," + G.toFixed(0) + ",0)";

}

function DrawRange(context, X, XEnd, Y, YEnd, ColorBack, ColorFront)
{
	if(X < XEnd)
	{
		var W = XEnd - X;
		var H = YEnd - Y;
		context.globalAlpha = 0.1;
		context.fillStyle = ColorBack;
		context.fillRect(X, Y, W, H);
		context.globalAlpha = 1;
		context.strokeStyle = ColorFront;
		context.beginPath();
		context.moveTo(X, 0);
		context.lineTo(X, H);
		context.moveTo(X+W, 0);
		context.lineTo(X+W, H);
		// context.closePath();
		context.stroke();
	}
}

function MouseInRect(Rect)
{
	return MouseInside(Rect.x, Rect.y, Rect.w, Rect.h);
}
function MouseInside(X, Y, W, H)
{
	return MouseX >= X && MouseX <= X + W && MouseY >= Y && MouseY <= Y + H;
}

var MessageText = "";
var MessageTimeout = -1;
var MessageTimeoutLast = new Date();
var MessageShowSpinner = 0;
function SetMessage(text, TimeOut, ShowSpinner)
{
	if(TimeOut)
	{
		MessageTimeout = TimeOut;
	}
	else
	{
		MessageTimeout = -1;
	}
	MessageText = text;
	MessageShowSpinner = ShowSpinner;
}
function ClearMessage(Message)
{
	if(Message == MessageText)
	{
		MessageText = "";
		MessageTimeout = -1;
	}
}

function DrawMessage()
{
	return;
	var context = CanvasDetailedView.getContext('2d');
	var Now = new Date();
	var Delta = Now - MessageTimeoutLast;
	if(MessageTimeout>0)
	{
		MessageTimeout -= Delta;
		if(MessageTimeout<= 0)
		{
			MessageText = "";
			MessageTimeout = -1;
		}

	}
	MessageTimeoutLast = Now;

	var Text = MessageText;
	var X = nWidth / 2;

	var Y = nHeight / 2;
	context.font = FontFlash;
	context.textAlign = 'center';
	context.fillStyle = 'red';

	function MSG(a, Spinner)
	{
		context.fillText(a, X, Y);
		if(Spinner)
		{
			var w = context.measureText(a).width;
			SpinnerDraw(1, context, SpinnerText0, X + 3 + w*0.5, Y - 25,  30, 30);
			SpinnerDraw(1, context, SpinnerText1, X - 3 - w*0.5 - 30, Y - 25,  30, 30);
		}
		Y -= 60;
	}
	if(!HelpFade)
		HelpFade = new Date();
	var HelpFadeTime = new Date() - HelpFade;
	if(HelpFadeTime < 2000)
	{
		var Alpha = 1 - (HelpFadeTime/2000);
		context.globalAlpha = Alpha;
		context.fillText("Press 'h' for help", X, 200);
		context.globalAlpha = 1;
	}

	if(Text != "")
	{
		MSG(Text);
	}
	if(IsFrozen)
	{
		MSG("FROZEN[space]");
	}

	PresetPending++; //hack: wait 20 frames before showing enable messages to prevent it from showing when loading settings. [[[test]]]
	if(WSIsOpen && PresetPending > 20)
	{
		if(Settings.ViewActive != VIEW_COUNTERS)
		{
			if(GroupsEnabled == 0)
			{
				MSG("Paused: Enable groups in 'Control' menu to unpause");
			}
			if(TimersEnabled == 0 && Settings.ViewActive != VIEW_GRAPH_THREAD_GROUP)
			{
				MSG("Enable Timers or Functions");
			}
		}
	}
	context.textAlign = 'left';
	context.font = Font;
}

function DrawGraphSettingsMenu(context, XBase, Y, width, height)
{
	if(SubMenuActive != SubMenuGraphSettings)
	{
		SubMenuGraphSettingsIndex = -1;
		SubMenuGraphSettingsKey = "";
	}
	if(!ShowMenu())
	{
		return;
	}
	if(!(Settings.ViewActive == VIEW_GRAPH_SPLIT || Settings.ViewActive == VIEW_GRAPH_PERCENTILE))
	{
		return;
	}
	let NumGraphs = 0;
	let TimerMap = FrameData.TimerMap;

	for(let key in TimerMap)
	{
		if(!IsGroup(key))
		{
			let idx = GetTimer(key);
			if(TimerArray[idx].e)
			{
				NumGraphs++;
			}
		}
	}
	let h = height;
	let w = width;
	let hstart = Y;
	let gh = h / NumGraphs;
	NumGraphs = 0;
	for(let key in TimerMap)
	{
		if(!IsGroup(key))
		{
			let idx = GetTimer(key);
			if(TimerArray[idx].e)
			{
				let X = XBase+1;
				let Y = hstart+1;
				let MenuText = ">";
				let w2 = 2 + context.measureText(MenuText).width;
				let bMouseInside = MouseInside(X, Y, w2, 4 + FontHeight);
				context.fillStyle = bMouseInside || (SubMenuGraphSettings == SubMenuActive && SubMenuGraphSettingsIndex == NumGraphs) ? nBackColors[1] : 'black';
				context.fillRect(X, Y, w2, 4 + FontHeight);
				context.fillStyle = '#ffffff';
				context.fillText(MenuText, X, Y + FontHeight);
				context.textAlign = 'left';
				if(bMouseInside)
				{
					SubMenuGraphSettingsIndex = NumGraphs;
					SubMenuGraphSettingsKey = key;
					CaptureButtonX = X + w2 + 2;
					CaptureButtonY = Y;
					EnableMenu(SubMenuGraphSettings);
				}
				NumGraphs++;
				hstart += gh;


			}
		}
	}
}

function DrawCaptureMenu(context)
{
	return;
	MouseInCaptureButton = 0;
	if(!ShowMenu())
	{
		return;
	}

	var CaptureRange = MouseDragActiveXStart < MouseDragActiveXEnd ? "Selection" : (""+Settings.CaptureFrames);
	var CaptureText = "Capture[" + CaptureRange + "]";
	var w = 10 + context.measureText(CaptureText).width;
	var X = nWidth / 2 - w / 2;
	var XCenter = nWidth / 2;
	var Y = nHeight - 30;
	MouseInCaptureButton = MouseInside(X, Y, w, 4 + FontHeight);
	context.textAlign = 'center';
	context.fillStyle = MouseInCaptureButton ? nBackColors[1] : 'black';
	context.fillRect(X, Y, w, 4 + FontHeight);
	context.fillStyle = '#ffffff';
	context.fillText(CaptureText, XCenter, Y + FontHeight);



	X += w + 2;
	var MenuText = "^";
	var w2 = 10 + context.measureText(MenuText).width;
	var bMouseInCaptureMenu = MouseInside(X, Y, w2, 4 + FontHeight);
	context.fillStyle = bMouseInCaptureMenu ? nBackColors[1] : 'black';
	context.fillRect(X, Y, w2, 4 + FontHeight);

	context.fillStyle = '#ffffff';
	context.fillText(MenuText, X + w2*0.5, Y + FontHeight);

	let X1 = X + w2 + 10;
	if(CaptureTriggerDelta)
	{
		let text = FormatTime(CaptureTriggerDelta);
		let w = 10 + context.measureText("text").width;
		context.fillStyle = 'black';
		context.fillRect(X1, Y, w, 4 + FontHeight);
		context.fillStyle = '#ffffff';
		context.fillText(text, X1 + w*0.5, Y + FontHeight);
		X1 += w;
	}

	let Pending = (CaptureTriggerTime != null && CaptureTriggerTimeType == 2);
	if(AutoCaptureEnabled || Pending)
	{
		let d = Dots();
		let AutoStatus = Pending ? (" pending" + Dots()) : "";
		let Source = GetAutoCaptureString();
		let Threshold = FormatTime(Settings.AutoCaptureTheshold);
		let str = "Autocapture " + AutoStatus + " Source:'" + Source + "' Threshold:" + Threshold + "ms Repeat=" + (Pending?Settings.AutoCaptureRepeat:AutoCaptureEnabled);
		let w = 10 + context.measureText(str).width;
		context.fillStyle = 'black';
		context.fillRect(X1, Y, w, 4 + FontHeight);
		context.fillStyle = '#ffffff';
		context.fillText(str, X1 + w*0.5, Y + FontHeight);
		X1 += w;
	}

	context.textAlign = 'left';
	if(bMouseInCaptureMenu)
	{
		CaptureButtonX = X + w2;
		CaptureButtonY = Y;
		EnableMenu(SubMenuCapture);
	}
}

function DrawRootGraphMenuElement(context)
{
	//MouseInGraphButton = -1;
	MouseInGraphModeButton = -1;
	if(!ShowMenu())
	{
		return;
	}
	let y = 0;
	let h = nHeight;
	if(HasVideoTrack())
		h -= VideoTrackHeight;

	let ydelta = h / GraphSettings.NumGraphs;
	for(let i = 0; i < GraphSettings.NumGraphs; ++i)
	{
		let Text = "Source";
		var w = 10 + context.measureText(Text).width;
		var X = nWidth / 2 - w / 2;
		var XCenter = nWidth / 2;
		var Y = y;
		let Inside = MouseInside(X, Y, w, 4 + FontHeight) ;

		context.textAlign = 'center';
		context.fillStyle = Inside ? nBackColors[1] : 'black';
		context.fillRect(X, Y, w, 4 + FontHeight);
		context.fillStyle = '#ffffff';
		context.fillText(Text, XCenter, Y + FontHeight);
		context.textAlign = '';

		if(Inside && MouseInGraphButton == -1)
		{
			MouseInGraphButton = i;
			GraphButtonX = X + 4;
			GraphButtonY = Y + FontHeight + 4;
			GraphButtonIndex = MouseInGraphButton;
			EnableMenu(SubMenuGraph);
		}

		X += w + 10;

		if(i == 0)
		{
			Text = "Mode";
			w = 10 + context.measureText(Text).width;
			XCenter = X + w / 2;
			Inside = MouseInside(X, Y, w, 4 + FontHeight) ;

			context.textAlign = 'center';
			context.fillStyle = Inside ? nBackColors[1] : 'black';
			context.fillRect(X, Y, w, 4 + FontHeight);
			context.fillStyle = '#ffffff';
			context.fillText(Text, XCenter, Y + FontHeight);
			context.textAlign = '';

			if(Inside)
			{
				MouseInGraphModeButton = i;
				GraphModeButtonX = X + 2;
				GraphModeButtonY = Y + FontHeight + 2;
				GraphModeButtonIndex = MouseInGraphModeButton;
				EnableMenu(SubMenuGraphMode);
			}

			X += w + 10;


			Text = "Preset";
			w = 10 + context.measureText(Text).width;
			XCenter = X + w / 2;
			Inside = MouseInside(X, Y, w, 4 + FontHeight) ;

			context.textAlign = 'center';
			context.fillStyle = Inside ? nBackColors[1] : 'black';
			context.fillRect(X, Y, w, 4 + FontHeight);
			context.fillStyle = '#ffffff';
			context.fillText(Text, XCenter, Y + FontHeight);
			context.textAlign = '';

			if(Inside)
			{
				// MouseInGraphModeButton = i;
				GraphModeButtonX = X + 2;
				GraphModeButtonY = Y + FontHeight + 2;
				// GraphModeButtonIndex = MouseInGraphModeButton;
				EnableMenu(SubMenuPresets2);
			}

			X += w + 10;







			if(CSVNumSets > 1)
			{
				let Text = "Set: " + (CSVActiveSet == 0 ? "All" : CSVSetNames[CSVActiveSet-1]);
				w = 10 + context.measureText(Text).width;
				XCenter = X + w / 2;
				Inside = MouseInside(X, Y, w, 4 + FontHeight) ;

				context.textAlign = 'center';
				context.fillStyle = Inside ? nBackColors[1] : 'black';
				context.fillRect(X, Y, w, 4 + FontHeight);
				context.fillStyle = '#ffffff';
				context.fillText(Text, XCenter, Y + FontHeight);
				context.textAlign = '';

				if(Inside && MouseReleased)
				{
					CSVActiveSet = (CSVActiveSet + 1) % (CSVNumSets+1);
					gGraphCSVInvalid = 1;
					RequestDraw();
				}
			}


		}
		y += ydelta;
	}
}


function DrawViews()
{
	Plotf("DrawViews");
	ProfileEnter("UpdateViews");
	ViewIndex = 0;
	for(let i = 0; i < Views.length; ++i)
	{
		let View = Views[i];
		let LocalMouseX = MouseX - View.x;
		let LocalMouseY = MouseY - View.y;
		if(View.visible && View.InvalidFunc(View, LocalMouseX, LocalMouseY, View.index))
		{
			let Canvas = View.Canvas[View.BackBuffer];
			let Context = Canvas.getContext('2d');
			View.DisplayFunc(1, View, Canvas, Context, LocalMouseX, LocalMouseY, View.index);
			ViewIndex++;
		}
	}
	ProfileLeave();
	var context = CanvasDetailedView.getContext('2d');
	context.clearRect(0, 0, nWidth, nHeight);
	ProfileEnter("BlitViews",1);
	for(var i = 0; i < Views.length; ++i)
	{
		var View = Views[i];
		let LocalMouseX = MouseX - View.x;
		let LocalMouseY = MouseY - View.y;
		if(View.visible)
		{
			context.drawImage(View.Canvas[View.BackBuffer], Math.floor(View.x), Math.floor(View.y), View.w, View.h);

			View.DisplayFunc(0, View, CanvasDetailedView, context, LocalMouseX, LocalMouseY, View.index);

		}
	}
	ProfileLeave();
	DrawCaptureMenu(context);
	DrawGraphSettingsMenu(context, MainView.x, MainView.y, MainView.w, MainView.h);

	if(!KeyZDown)
	{
		DrawRootGraphMenuElement(context);
	}




}
var SubMenuGroup = 0;
var SubMenuTimers = 1;
var SubMenuModules = 2;
var SubMenuFunctions = 3;
var SubMenuPatched = 4;
var SubMenuSettings = 5;
var SubMenuViews = 6;
var SubMenuPresets = 7;
var SubMenuColumns = 8;
var SubMenuCapture = 9;


var SubMenuGraphSettings = 10;
var SubMenuGraphSettingsIndex = -1;
var SubMenuGraphSettingsKey = "";
let SubMenuGraph = 11;

let SubMenuGraphMode = 12;
var SubMenuPresets2 = 13;


var SubMenuActive = -1;
var SubMenuTimeoutBase = 0.7;
var SubMenuMouseX = 0;
var SubMenuMouseY = 0;
var SubMenuTimeout = new Date();
var MenuItems = [];
var FilterInputTimersValue = '';
var FilterInputGroupsValue = '';
var FilterInputModulesValue = '';
var FilterInputFunctionsValue = '';
var FilterInputPatchedValue = '';


function MakeMenuItem(name, f, visible)
{
	var Item = {};
	Item.name = name;
	Item.f = f;
	Item.w = name.length;
	Item.x = 0;
	Item.y = 0;
	Item.visible = visible;
	return Item;
}
function EnableMenu(m)
{
	if(MouseDragSelectRange())
	{
		return;
	}
	gGraphCSVInvalid = 1;
	if(m != SubMenuActive)
	{

		if(SubMenuActive == SubMenuTimers)
		{
			FilterInputTimersValue = FilterInput.value;
		}
		else if(SubMenuActive == SubMenuGroup)
		{
			FilterInputGroupsValue = FilterInput.value;
		}
		else if(SubMenuActive == SubMenuModules)
		{
			FilterInputModulesValue = FilterInput.value;
		}
		else if(SubMenuActive == SubMenuFunctions)
		{
			FilterInputFunctionsValue = FilterInput.value;
		}
		else if(SubMenuActive == SubMenuPatched)
		{
			FilterInputPatchedValue = FilterInput.value;
		}

		SubMenuActive = m;
		SubMenuTimeout = new Date();

		if(SubMenuActive == SubMenuTimers)
		{
			FilterInput.value = FilterInputTimersValue;
		}
		else if(SubMenuActive == SubMenuGroup)
		{
			FilterInput.value = FilterInputGroupsValue;
		}
		else if(SubMenuActive == SubMenuModules)
		{
			FilterInput.value = FilterInputModulesValue;
		}
		else if(SubMenuActive == SubMenuFunctions)
		{
			FilterInput.value = FilterInputFunctionsValue;
		}
		else if(SubMenuActive == SubMenuPatched)
		{
			FilterInput.value = FilterInputPatchedValue;
		}

		FilterInputValueLast = FilterInput.value;
	}
	if(m == -1)
	{
		SubMenuTimeout = 0;
	}

	if(SubMenuActive == SubMenuTimers || SubMenuActive == SubMenuGroup || SubMenuActive == SubMenuModules || SubMenuActive == SubMenuFunctions || SubMenuActive == SubMenuPatched || SubMenuActive == SubMenuGraph)
	{
		FilterInputDiv.style['display'] = 'inline';
		FilterInput.focus();
	}
	else
	{
		FilterInputDiv.style['display'] = 'none';
	}
}

function Clamp(v, low, high)
{
	return v < low ? low : (v > high ? high : v);
}
function TriggerCapture()
{
	if(Settings.CaptureDelay <= 0)
	{
		Capture();
	}
	else
	{
		CaptureTriggerTime = new Date();
		CaptureTriggerTimeType = 1;
	}
}

function InitMenu()
{
	MenuItems = [];
	MenuItems.push(MakeMenuItem("Control", function(){EnableMenu(SubMenuGroup); } ));
	MenuItems.push(MakeMenuItem("Timers", function(){EnableMenu(SubMenuTimers); } ));
	MenuItems.push(MakeMenuItem("Modules", function(){EnableMenu(SubMenuModules); } ));
	MenuItems.push(MakeMenuItem("Functions", function(){EnableMenu(SubMenuFunctions); } ));
	MenuItems.push(MakeMenuItem("Patched", function(){EnableMenu(SubMenuPatched); }, function(){ return FunctionsInstrumented.length > 0;} ));
	MenuItems.push(MakeMenuItem("Settings", function(){ EnableMenu(SubMenuSettings); } ));
	MenuItems.push(MakeMenuItem("Views", function(){ EnableMenu(SubMenuViews); } ));
	MenuItems.push(MakeMenuItem("Presets", function(){ EnableMenu(SubMenuPresets); } ));
	MenuItems.push(MakeMenuItem("Columns", function(){ EnableMenu(SubMenuColumns); } ));
}
function DrawTopMenu()
{
	return;
	var context = CanvasDetailedView.getContext('2d');
	var X = 2;
	var Y = 0;
	var MouseInY = MouseY < BoxHeight;
	for(var i = 0; i < MenuItems.length; ++i)
	{
		if(i == SubMenuColumns)
		{
			if(Settings.ViewActive == VIEW_GRAPH_SPLIT ||
				Settings.ViewActive == VIEW_GRAPH_THREAD_GROUP ||
				Settings.ViewActive == VIEW_GRAPH_PERCENTILE ||
				Settings.ViewActive == VIEW_COUNTERS ||
				Settings.ViewActive == VIEW_CSV)
			{
				continue;
			}
		}
		var Item = MenuItems[i];
		if(Item.visible == null || Item.visible())
		{
			var w = context.measureText(Item.name).width + 4;
			var MouseIn = MouseInY && MouseX >= X && MouseX < X + w;
			var color = MouseIn ? nBackColors[1] : "black";
			Item.x = X;
			Item.y = Y + BoxHeight;
			if(MouseIn)
			{
				context.fillStyle = 'white';
				context.fillRect(X-2, Y, w+4, BoxHeight);
				// Enable
				EnableMenu(i);
			}
			context.fillStyle = color;
			context.fillRect(X, Y, w, BoxHeight);
			context.fillStyle = "white";
			context.fillText(Item.name, X+2, Y+BoxHeight-FontAscent);
			if(MouseIn && MouseReleased)
			{
				Item.f();
			}
			X += w + 6;
		}
	}
}

function AggregateMenuSize()
{
	var w = 250 + 5 + FontWidth;
	return WindowRect(nWidth / 2 - w / 2,HistoryHeight + 50, w, nHeight);
}
function TimerMenuSize()
{
	return MenuSize(WidthArray[TYPE_TIMER] + WidthArray[TYPE_GROUP] + 5 + FontWidth);
}

function GroupMenuSize()
{
	return MenuSize(WidthTree);
}

function MenuSize(w)
{
	return WindowRect(nWidth / 2 - w / 2, HistoryHeight + 50,w, nHeight);
}

function CreateFilter(Filter)
{
	if(!Filter || Filter.length == 0)
	{
		return null;
	}
	Filter = Filter.split(' ');

	var regexp = "";
	for(var i = 0; i < Filter.length; ++i)
	{
		regexp = regexp + ".*" + Filter[i];
	}
	Filter = new Array();
	regexp = regexp + ".*";
	Filter.push(new RegExp(regexp, "i"));
	return Filter;
}

function FilterMatch(FilterArray, value)
{
	if(!FilterArray)
		return true;
	for(var i = 0; i < FilterArray.length; ++i)
	{
		var res = value.search(FilterArray[i]);
		if(res<0)
			return false;
	}
	return true;
}

function AddPreset(Name)
{
	var O = {};
	O[Name] = {};
	var OO = {};
	OO.p = O;
	OO.r = {};
	AddPresets(OO);
}
function JSONTryParse(str)
{
	if(typeof str == 'string')
	{
		try{
			return JSON.parse(str);
		}
		catch(e){}
	}
	return {};
}

function ProcessPresets(Data, Names, Cache)
{
	for(var idx in Data)
	{
		if(Names.indexOf(idx) == -1)
		{
			Names.push(idx);
		}
		Cache[idx] = JSONTryParse(Data[idx]);
	}
}
function AddPresets(Obj)
{
	var Names = Obj.p;
	var ReadOnlyNames = Obj.r;
	ProcessPresets(Obj.p, Presets, PresetsCache);
	ProcessPresets(Obj.r, ReadOnlyPresets, ReadOnlyPresetsCache);
}
function GetFullName(T)
{
	var parent = T.parent;
	var ParentName = "unknown";
	var Name = T.name;
	if(parent && parent < TimerArray.length)
	{
		ParentName = TimerArray[parent].name;
	}
	return ParentName + "/" + Name;
}

function ColorFromFullName(name, type)
{
	for(var i = 0; i < TimerArray.length; ++i)
	{
		var t = TimerArray[i];
		if(t.idtype == type && GetFullName(t) == name)
		{
			return t.color;
		}
	}
	return 'white';

}
function EnableByName(name, type)
{
	for(var i = 0; i < TimerArray.length; ++i)
	{
		var t = TimerArray[i];
		if(t.idtype == type && GetFullName(t) == name)
		{
			WSSendMessage("c" + t.id);
		}
	}
}


function OnLoadPreset(NewSettings, Apply, RO)
{
	if(Apply)
	{
		WSSendMessage("d");
		PresetPending = 0;
	}
	ActivePreset = NewSettings.PresetName;
	ActivePresetRO = RO ? 1 : 0;
	console.log('loading preset ' + ActivePresetRO);
	var EnableCount = 0;
	for(var idx in NewSettings)
	{
		if(idx == 'Timers')
		{
			if(Apply)
			{
				var Timers = NewSettings[idx];
				for(var i = 0; i < Timers.length; ++i)
				{
					var FullName = Timers[i];
					EnableCount++;
					EnableByName(FullName, TYPE_TIMER);
				}
			}
		}
		else if(idx == 'Groups')
		{
			if(Apply)
			{
				var Groups = NewSettings[idx];
				for(var i = 0; i < Groups.length; ++i)
				{
					var FullName = Groups[i];
					EnableByName(FullName, TYPE_GROUP);

				}
			}
		}
		else
		{
			Settings[idx] = NewSettings[idx];
		}
	}

	if(Settings.FunctionsInstrumented && Apply)
	{
		if(Settings.FunctionsInstrumented.length == Settings.FunctionsInstrumentedModule.length && Settings.FunctionsInstrumented.length == Settings.FunctionsInstrumentedUnmangled.length)
		{
			var Msg = "D" + Settings.FunctionsInstrumented.length + " ";
			for(var i = 0; i < Settings.FunctionsInstrumented.length; ++i)
			{
				Msg += Settings.FunctionsInstrumentedModule[i] + "!" + Settings.FunctionsInstrumentedUnmangled[i] + "!";
			}
			WSSendMessage(Msg);
		}
	}
	if(Settings.ViewActive >= 0)
	{
		ResizeCanvas();
	}
}
function SanitizeString(s)
{
	let r = "";
	for(let i = 0; i < s.length; ++i)
	{
		let c = s[i];
		if(!((c>='a' && c<='z') || (c >='A' && c <= 'Z') || (c >= '0' && c <= '9')))
		{
			r += '_';
		}
		else
		{
			r += c;
		}
	}
	return r;
}
function LoadPreset(Name, RO)
{
	Name = SanitizeString(Name);
	WSSendMessage((RO?"m":"l")+Name);
}

function SavePreset(Name)
{
	Name = SanitizeString(Name);
	AddPreset(Name);
	var Timers = [];
	var Groups = [];
	for(var i = 0; i < TimerArray.length; ++i)
	{
		var t = TimerArray[i];
		var idtype = TimerArray[i].idtype;
		if(t.e)
		{
			if(idtype == TYPE_TIMER)
			{
				Timers.push(GetFullName(t));
			}
			else if(idtype == TYPE_GROUP)
			{
				Groups.push(GetFullName(t));
			}
		}
	}

	Settings.Timers = Timers;
	Settings.Groups = Groups;
	Settings.PresetName = Name;
	let Clone = function(A)
	{
		let N = Array(A.length);
		for(var i = 0; i < A.length; ++i)
		{
			N[i] = A[i];
		}
		return N;
	};
	Settings.FunctionsInstrumented = Clone(FunctionsInstrumented);
	Settings.FunctionsInstrumentedModule = Clone(FunctionsInstrumentedModule);
	Settings.FunctionsInstrumentedUnmangled = Clone(FunctionsInstrumentedUnmangled);

	var JsonSettings = JSON.stringify(Settings);
	console.log('settings stored ' + JsonSettings);
	WSSendMessage("s"+Name+","+JsonSettings);
	ActivePreset = Name;
	ActivePresetRO = 0;
}
function DrawMenuPresets()
{
	var Selection = null;
	var SizeInfo = {};
	SizeInfo.h = BoxHeight * (Presets.length * 2);
	if(ReadOnlyPresets.length)
	{
		SizeInfo.h += BoxHeight * (Presets.length + 1);
	}
	var x = MenuItems[SubMenuPresets].x;
	var y = MenuItems[SubMenuPresets].y;

	var Width = 50;
	var WLeft = MeasureArray(0, ["Save ", "Load ", "Save As ..", "Builtin" ]);
	Width = MeasureArray(Width, Presets);
	var Width = 35 + Width + WLeft;
	SizeInfo.w = Width;
	SizeInfo.x = x;
	SizeInfo.y = y;

	var M = CreateMenuState(SizeInfo);
	var context = CanvasDetailedView.getContext('2d');

	var SettingsCached;
	var SettingsCachedY = 0;

	for(var i = 0; i < Presets.length; ++i)
	{
		var Active = (ActivePresetRO == 0 && ActivePreset == Presets[i]) ? 1 : 0;
		if(DrawMenuElementMouseIn(M))
		{
			SettingsCachedY = M.y;
			SettingsCached = PresetsCache[Presets[i]];
		}

		if(DrawMenuElement(M, Active, "Load", Presets[i], 'white', 0))
		{
			LoadPreset(Presets[i]);
		}
	}
	DrawMenuElement(M, 0, "---", "", 'white', 0);
	if(DrawMenuElement(M, 0, "Save As..", "", 'white', 0))
	{
		var str = ShowPrompt('Enter Preset Name', '');
		if(str.length>1)
		{
			SavePreset(str);
		}

	}

	for(var i = 0; i < Presets.length; ++i)
	{
		var Active = (ActivePresetRO == 0 && ActivePreset == Presets[i]) ? 1 : 0;
		if(DrawMenuElement(M, Active, "Save", Presets[i], 'white', 0))
		{
			SavePreset(Presets[i]);
		}
	}
	if(ReadOnlyPresets && ReadOnlyPresets.length > 0)
	{
		DrawMenuElement(M, 0, "---", "", 'white', 0);
		for(var i = 0; i < ReadOnlyPresets.length; ++i)
		{
			var Active = (ActivePresetRO && ActivePreset == ReadOnlyPresets[i]) ? 1 : 0;
			if(DrawMenuElementMouseIn(M))
			{
				SettingsCachedY = M.y;
				SettingsCached = ReadOnlyPresetsCache[ReadOnlyPresets[i]];
			}
			if(DrawMenuElement(M, Active, "Builtin", ReadOnlyPresets[i], 'white', 0))
			{
				LoadPreset(ReadOnlyPresets[i], 1);
			}
		}
	}
	SizeInfo.h = M.y - SizeInfo.y;


	if(SettingsCached)
	{
		var SizeLeft = 10 * FontWidth;
		var Timers = SettingsCached.Timers;
		var Groups = SettingsCached.Groups;
		var Patched = SettingsCached.Patched;
		var W = 0;
		var H = 0;
		if(Timers)
		{
			W = MeasureArray(W, Timers);
			H = 1 + Timers.length;
		}
		if(Groups)
		{
			W = MeasureArray(W, Groups);
			H = 1 + Groups.length;
		}
		if(Patched)
		{
			W = MeasureArray(W, Patched);
			H = 1 + Patched.length;
		}
		W += 40;
		H = H * (FontHeight+1);
		var M = CreateMenuState(SizeInfo);
		M.x += M.w + 5;
		M.y = SettingsCachedY;
		M.w = W;
		M.h = H;

		if(Groups && Groups.length)
		{
			DrawMenuElement(M, 0, "Groups", "", 'white', 0);
			for(var i = 0; i < Groups.length; ++i)
			{
				DrawMenuElement(M, 0, "", Groups[i], 'white', 0);
			}
		}
		if(Timers && Timers.length)
		{
			DrawMenuElement(M, 0, "Timers", "", 'white', 0);
			for(var i = 0; i < Timers.length; ++i)
			{
				DrawMenuElement(M, 0, "", Timers[i], ColorFromFullName(Timers[i], TYPE_TIMER), 0);
			}
		}
		if(Patched && Patched.length)
		{
			DrawMenuElement(M, 0, "Patched", "", 'white', 0);
			for(var i = 0; i < Patched.length; ++i)
			{
				DrawMenuElement(M, 0, "", Patched[i], 'white', 0);
			}
		}


	}

	return SizeInfo;
}

function DrawMenuColumns()
{
	var Selection = null;
	var SizeInfo = {};
	var BarColumnNames = GetBarColumnNames();
	var BarColumnEnabled = GetBarColumnEnabled();
	SizeInfo.h = BoxHeight * (BarColumnNames.length);
	var x = MenuItems[SubMenuColumns].x;
	var y = MenuItems[SubMenuColumns].y;

	var Width = MeasureArray(0, BarColumnNames);
	SizeInfo.w = Width;
	SizeInfo.x = x;
	SizeInfo.y = y;

	var M = CreateMenuState(SizeInfo);
	var context = CanvasDetailedView.getContext('2d');
	context.fillRect(M.x, M.y, Width, SizeInfo.h);


	for(var i = 0; i < BarColumnNames.length; ++i)
	{
		var Active = ActivePreset == Presets[i] ? 1 : 0;
		if(DrawMenuElement(M, BarColumnEnabled[i], BarColumnNames[i], "", 'white', 0))
		{
			BarColumnEnabled[i] = !BarColumnEnabled[i];
			for(var j = 0; j < ColumnsWidth.length; ++j)
			{
				ColumnsWidth[i] = 20;
			}
		}
	}

	SizeInfo.h = M.y - SizeInfo.y;
	return SizeInfo;

}


function ToggleView()
{
	Settings.ViewActive = (Settings.ViewActive+1) % VIEW_SIZE;
	ActivateView(Settings.ViewActive);
}

function ActivateView(idx)
{
	for(var i = 1; i < Views.length; ++i)
	{
		Views[i].visible = false;
	}
	History.visible = !Settings.ViewCompressed && idx != VIEW_CSV;
	//Views[i].visible = false;
	if(idx == VIEW_GRAPH_SPLIT)
	{
		MainView.DisplayFunc = DrawGraphSplit;
		MainView.visible = true;
	}
	else if(idx == VIEW_GRAPH_PERCENTILE)
	{
		MainView.DisplayFunc = DrawGraphPercentile;
		MainView.visible = true;
	}
	else if(idx == VIEW_GRAPH_THREAD_GROUP)
	{
		MainView.DisplayFunc = DrawGraphThreadGroup;
		MainView.visible = true;
	}
	else if(idx == VIEW_BAR)
	{
		MainView.DisplayFunc = DrawTableView;
		MainView.visible = true;
	}
	else if(idx == VIEW_COUNTERS)
	{
		MainView.DisplayFunc = DrawCounterView;
		MainView.visible = true;
	}
	else if(idx == VIEW_CSV)
	{
		CSVView.visible = true;
	}

	Settings.ViewActive = idx;
	ViewBarMaxMsTextLength  = 0;
	var hest = 3;
}
function DrawMenuViews()
{
	var ViewClick = function(idx, name)
	{
		ActivateView(idx);
	};
	var x = MenuItems[SubMenuViews].x;
	var y = MenuItems[SubMenuViews].y;
	return DrawMenuGeneric(ViewNames, Settings.ViewActive, ViewClick, x, y, ViewNames2);
}

function TweakValue(Value, Tweak, amount, Min, Max)
{
	var V = 0.98;
	if(Tweak<0)
	{
		for(var x = 0; x < Math.abs(Tweak); ++x)
		{
			var newValue = Math.floor(Value*V);
			if(newValue == Value)
			{
				Value--;
			}
			else
			{
				Value = newValue;
			}
		}
	}
	else
	{
		var RcpV = 1.0 / V;

		for(var x = 0; x < Tweak; ++x)
		{
			var newValue = Math.ceil(Value*RcpV);
			if(newValue == Value)
			{
				Value++;
			}
			else
			{
				Value = newValue;
			}
		}
	}
	if(Min!=null && Value < Min)
		Value = Min;
	if(Max!=null && Value > Max)
		Value = Max;
	return Value;

}

function NextValue(Presets, Value, Dir)
{
	var idx = 0;
	if(Dir > 0)
	{
		for(idx = 0;idx < Presets.length; ++idx)
		{
			if(Presets[idx] > Value)
			{
				break;
			}
		}
	}
	else
	{
		for(idx = Presets.length; idx >= 0; idx -= 1)
		{
			if(Presets[idx] < Value)
			{
				break;
			}
		}
	}
	idx = (idx + Presets.length) % Presets.length;
	return Presets[idx];
}
function AutoCaptureRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.AutoCaptureTheshold = SetDirect;
	}
	else if(Tweak)
	{
		Settings.AutoCaptureTheshold = TweakValue(Settings.AutoCaptureTheshold, Tweak, 0.98, 1, 500);
	}
	else if(Direction)
	{
		Settings.AutoCaptureTheshold = NextValue(AutoCaptureThesholdPresets, Settings.AutoCaptureTheshold, Direction);
	}
}
function AutoCaptureRepeatRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.AutoCaptureRepeat = SetDirect;
	}
	else if(Tweak)
	{
		Settings.AutoCaptureRepeat = TweakValue(Settings.AutoCaptureRepeat, Tweak, 0.98, 1, 500);
	}
	else if(Direction)
	{
		Settings.AutoCaptureRepeat = NextValue(AutoCaptureRepeatPresets, Settings.AutoCaptureRepeat, Direction);
	}
}
function CaptureRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.CaptureFrames = SetDirect;
	}
	else if(Tweak)
	{
		Settings.CaptureFrames = TweakValue(Settings.CaptureFrames, Tweak, 0.98, 5, 300);

	}
	else if(Direction)
	{
		Settings.CaptureFrames = NextValue(CaptureFramesPresets, Settings.CaptureFrames, Direction);
	}
}
function CaptureDelayRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.CaptureDelay = SetDirect;
	}
	else if(Tweak)
	{
		Settings.CaptureDelay = TweakValue(Settings.CaptureDelay, Tweak, 0.98, 5, 300);

	}
	else if(Direction)
	{
		Settings.CaptureDelay = NextValue(CaptureDelayPresets, Settings.CaptureDelay, Direction);
	}
}

function GetAutoCaptureString()
{
	if(AutoCaptureSourceIndex >= 0)
	{
		if(AutoCaptureSourceIndex >= EnabledArray.length)
		{
			AutoCaptureSourceIndex = -1;
			AutoCaptureSourceIndex = -1;
		}
		else
		{
			var idx = EnabledArray[AutoCaptureSourceIndex];
			return TimerArray[idx].name;
		}
	}
	return "Frame Time";
}

function AutoCaptureSourceRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{

	}else if(Tweak||Direction)
	{
		if(!Direction)
			Direction = Tweak;
		if(Direction<0)
		{
			AutoCaptureSourceIndex--;
			if(AutoCaptureSourceIndex<-1)
			{
				AutoCaptureSourceIndex = EnabledArray.length-1;
			}
		}
		else
		{
			AutoCaptureSourceIndex++;
			if(AutoCaptureSourceIndex >= EnabledArray.length)
			{
				AutoCaptureSourceIndex = -1;
			}
		}

	}
}

function ShowPrompt(Title, Value, Type)
{
	var v;
	if(Type == 'int')
	{
		var newValue = prompt('' + Title, '' + Value);
		v = parseInt(newValue);
	}
	else if(Type == 'float')
	{
		var newValue = prompt('' + Title, '' + Value);
		v = parseFloat(newValue);
	}
	else
	{
		var v = prompt('' + Title, '' + Value);
		return v;
	}
	if(isNaN(v))
	{
		return Value;
	}
	else
	{
		return v;
	}

}
function MeasureArray(v, A, f)
{
	let context = CanvasDetailedView.getContext('2d');
	for(let i = 0; i < A.length; ++i)
	{
		let s = A[i];
		if(f)
			s=f(s, i);
		let l = context.measureText(s).width;
		v = v < l ? l : v;
	}
	return v;
}
function MeasureObjectKeys(v, A, f)
{
	let context = CanvasDetailedView.getContext('2d');
	for(let i in A)
	{
		let l = context.measureText(i).width;
		v = v < l ? l : v;
	}
	return v;
}

function CreateMenuState(SizeInfo)
{
	var MenuState = {};
	for(var i in SizeInfo)
	{
		MenuState[i] = SizeInfo[i];
	}
	MenuState.cidx = 0;
	return MenuState;
}
function DrawMenuElementMouseIn(M)
{
	return MouseY >= M.y && MouseY < M.y + BoxHeight && MouseX >= M.x && MouseX <= M.x + M.w;
}
function DrawMenuElement(M, Selected, Name, Value, color)
{
	var context = CanvasDetailedView.getContext('2d');

	var bMouseIn = DrawMenuElementMouseIn(M);
	var YText = M.y + BoxHeight - FontAscent;

	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[M.cidx];
	context.textAlign = 'left';
	context.fillStyle = Selected?'white':bgcolor;
	context.fillRect(M.x-2, M.y, M.w + 4, BoxHeight);
	context.fillStyle = bgcolor;
	context.fillRect(M.x, M.y, M.w, BoxHeight);
	context.fillStyle = color;
	context.fillText(Name, M.x, YText);
	context.textAlign = 'right';
	context.fillText('' + Value, M.x + M.w - 2, YText);
	context.textAlign = 'left';
	M.cidx = 1-M.cidx;
	M.y += BoxHeight;
	return bMouseIn && MouseReleased;
}
function DrawMenuRoll(M, Name, RollValue, RollExt, RollFunction, Tweak, Type)
{
	var context = CanvasDetailedView.getContext('2d');

	var YText = M.y + BoxHeight - FontAscent;
	var SizeMinus = context.measureText('-').width;
	var SizePlus = context.measureText('+').width;

	var bMouseIn = MouseY >= M.y && MouseY < M.y + BoxHeight;
	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[M.cidx];
	context.fillStyle = bgcolor;
	context.fillRect(M.x-2, M.y, M.w+4, BoxHeight);
	context.fillStyle = 'white';
	context.fillText(Name, M.x, YText);
	context.textAlign = 'right';
	var XTemp = M.x + M.w - 3;

	if(KeyShiftDown && bMouseIn)
	{
		if(Tweak>=0)
		{
			RollFunction(0, MouseX-Tweak);
		}
		Tweak = MouseX;
		bMouseIn = false;
	}
	else
	{
		Tweak = -1;
	}

	var MouseReleasedUsed = false;
	if(bMouseIn && MouseX >= XTemp - SizePlus && MouseX <= XTemp)
	{
		context.fillStyle = 'red';
		if(MouseReleased)
		{
			RollFunction(1);
			MouseReleasedUsed = true;
		}
	}
	else
	{
		context.fillStyle = 'white';
	}
	context.fillText('+', XTemp, YText);
	XTemp -= SizePlus + 3;



	if(bMouseIn && MouseX >= XTemp - SizeMinus && MouseX <= XTemp)
	{
		context.fillStyle = 'red';
		if(MouseReleased)
		{
			RollFunction(-1);
			MouseReleasedUsed = true;
		}
	}
	else
	{
		context.fillStyle = 'white';
	}

	context.fillText('-', XTemp, YText);
	XTemp -= SizeMinus + 3;
	var RollText = ''+RollValue + RollExt;
	var RollWidth = context.measureText(RollText).width;
	context.fillStyle = 'white';

	context.fillText(RollText, XTemp, YText);
	XTemp -= RollWidth;

	context.textAlign = 'left';

	M.cidx = 1-M.cidx;

	M.y += BoxHeight;
	if(Type && MouseReleased && bMouseIn && !MouseReleasedUsed)
	{
		var V = ShowPrompt(Name, RollValue, Type);
		RollFunction(0,0,V);
	}
	return Tweak;

}
function CheckPopupAllowed()
{
	if(!PopupsAllowed && !PopupTestPending)
	{
		PopupTestPending = 1;
		PopupsAllowed = 0;
		PopupsFailed = 0;
		let DoPopupTest = function()
		{
			var W = window.open("about:blank");
			var Fail = function()
			{
				PopupTestPending = 0;
				PopupsFailed = 1;
				PopupsAllowed = 0;
			};
			var Check = function()
			{
				if(!(W.innerHeight>0))
					Fail();
				else
				{
					PopupTestPending = 0;
					PopupsFailed = 0;
					PopupsAllowed = 1;
					W.close();
				}
			};
			if(W)
			{
				if(/chrome/.test(navigator.userAgent.toLowerCase()))
					setTimeout(Check, 200);
				else
					W.onload = Check;
			}
			else
			{
				Fail();
			}
		};
		setTimeout(DoPopupTest, 5000);
	}
}

function GetSubGraphReferenceTime(SubGraphSettings, TimerState)
{
	if(SubGraphSettings.AutomaticReference)
	{
	 	return TimerState.historymaxsoft ? TimerState.historymax : TimerState.historymax;
	}
	else
	{
		return SubGraphSettings.ReferenceTime;
	}
}
function GetSubGraphSettingsKey(key)
{
	if(Settings.ViewActive == VIEW_GRAPH_PERCENTILE)
	{
		return "perc_"+key;
	}
	else
	{
		return key;
	}
}
function GetSubGraphSettings(key)
{
	let k = GetSubGraphSettingsKey(key);
	let SubGraphSettings = Settings.SubGraphSettings[k];
	if(!SubGraphSettings)
	{
		SubGraphSettings = {"ReferenceTime":10.0, "TargetTime":-1, "AutomaticReference":1, "Percentile":0.0};
		Settings.SubGraphSettings[k] = SubGraphSettings;
	}
	return SubGraphSettings;
}


function DrawMenuGraphSettings()
{
	let Percentile = Settings.ViewActive == VIEW_GRAPH_PERCENTILE;
	let Selection = null;
	let SizeInfo = {};
	SizeInfo.h = (Percentile?3:2) * BoxHeight;
	let Strings = ["AutoCapture Enabled", "AutoCapture Threshold", "AutoCapture Source", "Capture Length"];
	let wLeft = MeasureArray(0, Strings);
	let wRight = 50;
	wRight = MeasureArray(wRight, ["Frame Time"]);
	wRight = MeasureArray(wRight, EnabledArray, function(a){return TimerArray[a].name; } );
	let Width = wLeft + 35 + wRight;
	SizeInfo.w = Width;
	SizeInfo.x = CaptureButtonX;
	SizeInfo.y = CaptureButtonY;

	let M = CreateMenuState(SizeInfo);
	let context = CanvasDetailedView.getContext('2d');
	context.fillRect(M.x, M.y, Width, SizeInfo.h);
	let SubGraphSettings = GetSubGraphSettings(SubMenuGraphSettingsKey);


	ReferenceTimeTweak = DrawMenuRoll(M, "Reference Time", SubGraphSettings.ReferenceTime, '', ReferenceRollSubGraph, ReferenceTimeTweak, 'int');
	if(DrawMenuElement(M, SubGraphSettings.AutomaticReference, "Automatic Reference Time", SubGraphSettings.AutomaticReference, 'white'))
	{
		SubGraphSettings.AutomaticReference = 1-SubGraphSettings.AutomaticReference;
	}
	if(Percentile)
	{
		//PercentileTweak = DrawMenuRoll(M, "Percentile", SubGraphSettings.Percentile, '', PercentileRollSubGraph, PercentileTweak, 'int');
		if(DrawMenuElement(M, 0, "Clear Aggregate", "", 'white'))
		{
			let TimerMap = FrameData.TimerMap;
			if(TimerMap)
			{
				let TimerState = TimerMap[SubMenuGraphSettingsKey];
				TimerState.PercentileMax = -1e38;
				TimerState.PercentileMin = 1e38;
				TimerState.Percentile = new Float32Array(PERCENTILE_SAMPLES);
				TimerState.Percentile.fill(0.0);
				TimerState.PercentileCount = 0;
			}
		}
	}
	SizeInfo.h = M.y - SizeInfo.y;
	return SizeInfo;

}


function DrawMenuGraph()
{
	let Selection = null;
	let SizeInfo = {};
	let NumColumns = 0;
	let wLeft = 0;
	let wRight = 0;//MeasureObjectKeys(20, CSVAllColumns);
	let context = CanvasDetailedView.getContext('2d');
	let data = Array();
	let LeftCount = 0;
	let LeftSet = {};
	let FilterArray = CreateFilter(FilterInput.value);

	for(let i in CSVAllColumns)
	{
		let index = i.indexOf('_');
		let l = '';
		let r = i;
		if(index > 0 && index < i.length-1)
		{
			l = i.substring(0, index);
			r = i.substring(index+1);
		}
		if(FilterMatch(FilterArray, l + " " + r))
		{
			wLeft = Math.max(wLeft, context.measureText(l).width);
			wRight = Math.max(wRight, context.measureText(r).width);
			let element = {};
			element.l = l;
			element.r = r;
			element.CName = i;
			if(!LeftSet[l])
			{
				LeftCount++;
				LeftSet[l] = 1;
			}
			NumColumns++;
			data.push(element);
		}
	}
	SizeInfo.h = (NumColumns) * BoxHeight;

	let comp = function(l, r){ return l.l.localeCompare(r.l);};
	data.sort(comp);

	let Width = wLeft + 25 + wRight;


	SizeInfo.w = Width;


	SizeInfo.x = GraphButtonX;
	SizeInfo.y = GraphButtonY;

	MoveFilterInputDiv(SizeInfo.x, SizeInfo.y, SizeInfo.w);




	let M = CreateMenuState(SizeInfo);
	M.y += 35;
	context.fillRect(M.x, M.y, Width, SizeInfo.h);

	let GraphSet = GraphSettings.Graphs[GraphButtonIndex];
	if(!GraphSet)
		debugger;

	let i = 0;
	if(data.length>0)
	{
		let LeftLast = null;
		for(let i in data)
		{
			let element = data[i];
			let CName = element.CName;
			if(LeftLast && LeftLast != element.l)
			{
				LeftLast = element.l;
				DrawMenuElement(M, 0, "---", "", 'white', 0);
			}


			let Active = GraphSet[CName] == 1;
			if(DrawMenuElement(M, Active, element.l, element.r, 'white'))
			{
				if(KeyCtrlDown)
				{
					for(let CName2 in CSVAllColumns)
						GraphSet[CName2] = 0;
					GraphSet[CName] = 1;
				}
				else
				{
					if(Active)
						GraphSet[CName] = 0;
					else
						GraphSet[CName] = 1;
				}
				gGraphCSVInvalid = 1;
				RangeInvalidate(RangeSelectState);
				WriteCookie();

			}
			i++;
		}
	}
	SizeInfo.h = M.y - SizeInfo.y;

	RequestDraw();
	return SizeInfo;
}

function DrawMenuGraphMode()
{
	let Selection = null;
	let SizeInfo = {};
	SizeInfo.h = 4 * BoxHeight;
	let Strings = ["Min/Max Region", "Average", "Min", "Max", "Percentil Min/Max Region", "Percentile Avg", "Percentile Min", "Percentile Max"];
	let wLeft = MeasureArray(0, Strings);
	let wRight = 50;
	wRight = MeasureArray(wRight, ["Frame Time"]);
	let Width = wLeft + 35 + wRight;

	SizeInfo.w = Width;
	SizeInfo.x = GraphModeButtonX;
	SizeInfo.y = GraphModeButtonY;

	let M = CreateMenuState(SizeInfo);
	let context = CanvasDetailedView.getContext('2d');
	context.fillRect(M.x, M.y, Width, SizeInfo.h);

	let Mask = 1;
	let GraphModeMask = GraphSettings.GraphModeMask;
	for(let i = 0; i < Strings.length; ++i)
	{
		let Active = 0 != (GraphModeMask&Mask);
		if(DrawMenuElement(M, Active, Strings[i], "", 'white'))
		{
			if(Active)
				GraphModeMask = GraphModeMask & ~Mask;
			else
				GraphModeMask = GraphModeMask | Mask;
			gGraphCSVInvalid = 1;
		}
		Mask = Mask << 1;
	}
	if(GraphSettings.GraphModeMask != GraphModeMask)
	{
		GraphSettings.GraphModeMask = GraphModeMask;
		WriteCookie();
	}

	SizeInfo.h = M.y - SizeInfo.y;

	RequestDraw();
	return SizeInfo;
}
function DeepClone(Obj)
{
	return JSON.parse(JSON.stringify(Obj));
}

function SetGraphPresetNamed(Name)
{
	if(PresetNamed[Name])
	{
		PresetSets[GraphPresetIndex] = DeepClone(PresetNamed[Name]);
		GraphSettings = PresetSets[GraphPresetIndex];
		gGraphCSVInvalid = 1;
		RequestDraw();
		WriteCookie();
	}
}


function SetGraphPreset(Index)
{
	if(!PresetSets[Index])
	{
		///deep clone. haters gonna hate. https://www.youtube.com/watch?v=nfWlot6h_JM
		PresetSets[Index] = DeepClone(PresetSets[GraphPresetIndex]);
	}
	GraphPresetIndex = Index;
	GraphSettings = PresetSets[GraphPresetIndex];
	gGraphCSVInvalid = 1;
	RequestDraw();
	WriteCookie();
}



function DrawMenuPresets2()
{
	let Selection = null;
	let SizeInfo = {};
	SizeInfo.h = 4 * BoxHeight;
	let NumNamed = 0;
	let Strings = ["Preset ***"];
	for(let Name in PresetNamed)
	{
		NumNamed++;
		Strings.push(Name);
	}
	let wLeft = MeasureArray(0, Strings);
	let Width = wLeft + 10;

	SizeInfo.w = Width;
	SizeInfo.x = GraphModeButtonX;
	SizeInfo.y = GraphModeButtonY;

	let M = CreateMenuState(SizeInfo);
	let context = CanvasDetailedView.getContext('2d');
	context.fillRect(M.x, M.y, Width, SizeInfo.h);

	let Mask = 1;

	for(let i = 0; i < MAX_PRESETS; ++i)
	{
		let Active = GraphPresetIndex == i;
		if(DrawMenuElement(M, Active, "Preset " + i, "", 'white'))
		{
			SetGraphPreset(i);
			gGraphCSVInvalid = 1;
		}
	}
	if(NumNamed>0)
	{
		DrawMenuElement(M, false, "---", "", 'white');
		for(let Name in PresetNamed)
		{
			if(DrawMenuElement(M, false, Name, "", 'white'))
			{
				SetGraphPresetNamed(Name);
			}
		}
	}


	SizeInfo.h = M.y - SizeInfo.y;
	RequestDraw();
	return SizeInfo;
}

function Dots()
{
	let t = new Date().getMilliseconds() / 200;
	let dots = [".  ",".. ","...",".. "];
	let x = Math.floor(t) %4;
	return dots[x];
}


function DrawMenuCapture()
{
	let Selection = null;
	let SizeInfo = {};
	SizeInfo.h = 7 * BoxHeight;
	let Strings = ["Popups Allowed", "AutoCapture Enabled", "AutoCapture Threshold", "AutoCapture Source", "Capture Length", "Capture Delay"];
	let wLeft = MeasureArray(0, Strings);
	let wRight = 50;
	wRight = MeasureArray(wRight, ["Frame Time"]);
	wRight = MeasureArray(wRight, EnabledArray, function(a){return TimerArray[a].name; } );
	let Width = wLeft + 35 + wRight;
	SizeInfo.w = Width;
	SizeInfo.x = CaptureButtonX - SizeInfo.w;
	SizeInfo.y = CaptureButtonY - SizeInfo.h;

	let M = CreateMenuState(SizeInfo);
	let context = CanvasDetailedView.getContext('2d');
	context.fillRect(M.x, M.y, Width, SizeInfo.h);
	let d = Dots();
	let PopupStatus = PopupsAllowed ? "Yes" :  (PopupsFailed ? "No" : (PopupTestPending ? ("Testing"+d) : "Untested"));
	if(DrawMenuElement(M, 0, "Popups Allowed", PopupStatus, 'white', 0))
	{
		CheckPopupAllowed();
	}
	let AutoStatus = AutoCaptureEnabled > 0 ? "on" : "off";
	if(CaptureTriggerTime != null && CaptureTriggerTimeType == 2)
	{
		AutoStatus = "pending"+d;
	}
	if(DrawMenuElement(M, 0, "AutoCapture Enabled", AutoStatus, 'white', 0))
	{
		if(!AutoCaptureEnabled && CaptureTriggerTime == null)
		{
			if(Settings.CaptureDelay <= 0)
			{
				AutoCaptureEnabled = Settings.AutoCaptureRepeat > 0 ? Settings.AutoCaptureRepeat : 1;
			}
			else
			{
				CaptureTriggerTime = new Date();
				CaptureTriggerTimeType = 2;
			}
		}
		else
		{
			AutoCaptureEnabled = 0;
			if(CaptureTriggerTimeType == 2)
			{
				CaptureTriggerTimeType = 0;
				CaptureTriggerTime = null;
			}
		}
	}
	AutoCaptureSourceTweak = DrawMenuRoll(M, "AutoCapture Source", GetAutoCaptureString(), '', AutoCaptureSourceRoll, AutoCaptureSourceTweak);
	AutoCaptureTweak = DrawMenuRoll(M, "AutoCapture Threshold", Settings.AutoCaptureTheshold, 'ms', AutoCaptureRoll, AutoCaptureTweak, 'int');
	AutoCaptureRepeatTweak = DrawMenuRoll(M, "AutoCapture Repeat", Settings.AutoCaptureRepeat, '', AutoCaptureRepeatRoll, AutoCaptureRepeatTweak, 'int');
	CaptureTweak = DrawMenuRoll(M, "Capture Length",  Settings.CaptureFrames, '', CaptureRoll, CaptureTweak, 'int');
	CaptureDelayTweak = DrawMenuRoll(M, "Capture Delay",  Settings.CaptureDelay, '', CaptureDelayRoll, CaptureDelayTweak, 'int');

	SizeInfo.h = M.y - SizeInfo.y;
	return SizeInfo;

}
function WindowRect(x,y,w,h)
{
	let s = {};
	s.x = x;
	s.y = y;
	s.w = w;
	s.h = h;
	return s;
}
function GetAggregateString()
{
	if(0 == Settings.AggregateFrames)
		return 'infinite';
	else
		return Settings.AggregateFrames + '';
}

function AggregateRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect || SetDirect == 0)
	{
		if(SetDirect <= 0 || SetDirect == 'infinite')
		{
			Settings.AggregateFrames = 0;
		}
		else
		{
			Settings.AggregateFrames = SetDirect;
		}
	}
	else if(Tweak)
	{
		Settings.AggregateFrames = TweakValue(Settings.AggregateFrames, Tweak, 0.98, 0, 500);

	}
	else if(Direction)
	{
		Settings.AggregateFrames = NextValue(AggregatePresets, Settings.AggregateFrames, Direction);
	}
}
function ReferenceRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.ReferenceTime = SetDirect;
	}
	else if(Tweak)
	{
		Settings.ReferenceTime = TweakValue(Settings.ReferenceTime, Tweak, 0.98, 5, 1000);

	}
	else if(Direction)
	{
		Settings.ReferenceTime = NextValue(ReferencePresets, Settings.ReferenceTime, Direction);
	}
}

function ReferenceRollSubGraph(Direction, Tweak, SetDirect)
{
	let SubGraphSettings = GetSubGraphSettings(SubMenuGraphSettingsKey);
	if(SetDirect)
	{
		SubGraphSettings.ReferenceTime = SetDirect;
	}
	else if(Tweak)
	{
		SubGraphSettings.ReferenceTime = TweakValue(SubGraphSettings.ReferenceTime, Tweak, 0.98, 5, 1000);

	}
	else if(Direction)
	{
		SubGraphSettings.ReferenceTime = NextValue(ReferencePresets, SubGraphSettings.ReferenceTime, Direction);
	}
}

function PercentileRollSubGraph(Direction, Tweak, SetDirect)
{
	let SubGraphSettings = GetSubGraphSettings(SubMenuGraphSettingsKey);
	if(SetDirect)
	{
		SubGraphSettings.Percentile = SetDirect;
	}
	else if(Tweak)
	{
		SubGraphSettings.Percentile = TweakValue(SubGraphSettings.Percentile, Tweak, 0.98, 5, 1000);
	}
	else if(Direction)
	{
		SubGraphSettings.Percentile = NextValue(PercentilePresets, SubGraphSettings.Percentile, Direction);
	}
}


function TargetRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.TargetTime = SetDirect;
	}
	else if(Tweak)
	{
		Settings.TargetTime = TweakValue(Settings.TargetTime, Tweak, 0.98, 5, 1000);

	}
	else if(Direction)
	{
		Settings.TargetTime = NextValue(ReferencePresets, Settings.TargetTime, Direction);
	}
}
function TargetRollSubGraph(Direction, Tweak, SetDirect)
{
	let SubGraphSettings = GetSubGraphSettings(SubMenuGraphSettingsKey);
	if(SetDirect)
	{
		SubGraphSettings.TargetTime = SetDirect;
	}
	else if(Tweak)
	{
		SubGraphSettings.TargetTime = TweakValue(SubGraphSettings.TargetTime, Tweak, 0.98, 5, 1000);

	}
	else if(Direction)
	{
		SubGraphSettings.TargetTime = NextValue(ReferencePresets, SubGraphSettings.TargetTime, Direction);
	}
}
function DrawMenuSettings()
{
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = AggregateMenuSize();
	SizeInfo.x = MenuItems[SubMenuSettings].x;
	SizeInfo.y = MenuItems[SubMenuSettings].y;

	SizeInfo.w = 200;
	var M = CreateMenuState(SizeInfo);

	AggregateTweak = DrawMenuRoll(M, "Aggregate Frames", GetAggregateString(), '', AggregateRoll, AggregateTweak, 'int');
	ReferenceTimeTweak = DrawMenuRoll(M, "Reference Time", Settings.ReferenceTime, '', ReferenceRoll, ReferenceTimeTweak, 'int');
	TargetTimeTweak = DrawMenuRoll(M, "Target Time", Settings.TargetTime, '', TargetRoll, TargetTimeTweak, 'int');
	if(DrawMenuElement(M, Settings.AutomaticReference, "Automatic Reference Time", Settings.AutomaticReference, 'white'))
	{
		Settings.AutomaticReference = 1-Settings.AutomaticReference;
	}
	if(DrawMenuElement(M, Settings.ViewCompressed, "Compressed View", Settings.ViewCompressed, 'white'))
	{
		Settings.ViewCompressed = 1-Settings.ViewCompressed;
		ResizeCanvas();
	}

	if(Settings.AggregateFrames <= 0)
	{
		if(DrawMenuElement(M, 0, "Clear Aggregate", "Current[" + AggregateCurrent + "]", 'white'))
		{
			WSSendMessage("r");
		}
	}
	if(DrawMenuElement(M, 0, "Clear Percentile Aggregate", "", 'white'))
	{
		let TimerMap = FrameData.TimerMap;
		if(TimerMap)
		{
			for(let key in TimerMap)
			{
				let idx = GetTimer(key);
				let TimerState = TimerMap[key];
				if(!IsGroup(key) && TimerState.Percentile)
				{
					TimerState.PercentileMax = -1e38;
					TimerState.PercentileMin = 1e38;
					TimerState.Percentile = new Float32Array(PERCENTILE_SAMPLES);
					TimerState.Percentile.fill(0.0);
					TimerState.PercentileCount = 0;
				}
			}
		}
	}


	if(DrawMenuElement(M, Settings.AllowHighDPI, "Allow High DPI", Settings.AllowHighDPI, 'white'))
	{
		Settings.AllowHighDPI = 1 - Settings.AllowHighDPI;
		ResizeCanvas();
	}
	if(DrawMenuElement(M, Cookie.CodeReportMode == 0, "Code Report: Prompt", Cookie.CodeReportMode == 0 ? 1 : 0, 'white'))
	{
		Cookie.CodeReportMode = 0;
		WriteCookie();
	}

	if(DrawMenuElement(M, Cookie.CodeReportMode == 1, "Code Report: Report Silently", Cookie.CodeReportMode == 1 ? 1 : 0, 'white'))
	{
		Cookie.CodeReportMode = 1;
		WriteCookie();
	}
	if(DrawMenuElement(M, Cookie.CodeReportMode == 2, "Code Report: Never Report", Cookie.CodeReportMode == 2 ? 1 : 0, 'white'))
	{
		Cookie.CodeReportMode = 2;
		WriteCookie();
	}

	SizeInfo.h = M.y - SizeInfo.y;
	return SizeInfo;
}

function MoveFilterInputDiv(x, y, w)
{
	if(FilterInputDivPos.x != x || FilterInputDivPos.y != y || FilterInputDivPos.w != w)
	{
		FilterInputDivPos.x = x;
		FilterInputDivPos.y = y;
		FilterInputDivPos.w = w;
		FilterInputDiv.style['left'] = x + 'px';
		FilterInputDiv.style['top'] = y + 'px';
		FilterInput.style['width'] = w + 'px';
	}
}

function DrawMenuTimer()
{
	if(FilterInputValueLast != FilterInput.value)
	{
		nOffsetMenuTimers = 0;
	}
	FilterInputValueLast = FilterInput.value;
	var FilterArray = CreateFilter(FilterInput.value);
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = TimerMenuSize();
	SizeInfo.x = MenuItems[SubMenuTimers].x;
	SizeInfo.y = MenuItems[SubMenuTimers].y;
	var Y = SizeInfo.y;
	var Width = SizeInfo.w;
	var Selection = null;
	var X = SizeInfo.x;
	MoveFilterInputDiv(SizeInfo.x, SizeInfo.y, SizeInfo.w);
	Y += 35;

	var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
	var bMouseInClear =  MouseY >= Y && MouseY < Y + BoxHeight;
	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
	var TextY = Y+BoxHeight-FontAscent;
	var YClear = Y;
	var TextYClear = TextY;
	var YStart = Y;

	var MouseTaken = bMouseIn;

	Y += BoxHeight;
	nColorIndex = 1-nColorIndex;

	Y -= nOffsetMenuTimers;

	for(var i = 0; i < TimerArray.length; ++i)
	{
		var v = TimerArray[i];
		if(v.idtype == TYPE_TIMER
		 //|| v.idtype == TYPE_GROUP
		 )
		{
			var Name = v.name;
			var ParentName = TimerArray[v.parent].name;
			if(FilterMatch(FilterArray, ParentName + " " + Name) && (0 == TimersActiveOnly || v.e))
			{
				if(Y > YStart)
				{
					var ParentColor = TimerArray[v.parent].e ? 'white' : 'grey';
					bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight && !MouseTaken;
					bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
					TextY = Y+BoxHeight-FontAscent;
					context.fillStyle = v.e?'white':bgcolor;
					context.fillRect(X-2, Y, Width+4, BoxHeight);
					context.fillStyle = bgcolor;
					context.fillRect(X, Y, Width, BoxHeight);
					context.fillStyle = ParentColor;
					context.fillText(ParentName, X + 2, TextY);
					context.fillStyle = v.color;
					context.textAlign = 'right';
					context.fillText(Name, X + Width - 2, TextY);
					context.textAlign = 'left';
					if(bMouseIn)
					{
						Selection = v.id;
					}
				}
				Y += BoxHeight;
				nColorIndex = 1-nColorIndex;
			}
		}
	}

	{

		var c0 = nBackColorOffset;
		var c1 = nBackColors[1];
		var W = Width + 4;
		var WHalf = W / 2;
		var InsideClear = bMouseInClear && MouseX-X< WHalf-1;
		var InsideActive =  bMouseInClear && MouseX-X > WHalf+1;
		context.fillStyle = nBackColors[0];
		context.fillRect(X-2, YClear, W, BoxHeight);

		context.fillStyle = InsideClear ? c0 :c1;
		context.fillRect(X-2, YClear, WHalf-1, BoxHeight);
		context.fillStyle = InsideActive ? c0 :c1;
		context.fillRect(X-2 + WHalf + 1, YClear, WHalf-1, BoxHeight);


		context.fillStyle = 'white';
		context.textAlign = 'center';
		context.fillText("[clear] ", X + 2 + Width * 0.25, TextYClear);
		context.fillStyle = TimersActiveOnly ? 'white' : 'grey';
		context.fillText("[active only]", X + 2 + Width * 0.75, TextYClear);
		if(MouseReleased)
		{
			if(InsideActive)
			{
				TimersActiveOnly = 1-TimersActiveOnly;
			}
			if(InsideClear)
			{
				WSSendMessage("x");
			}
		}
	}
	context.textAlign = 'left';
	if(Selection && MouseReleased && !MouseTaken)
	{
		WSSendMessage("c" + Selection);
	}
	SizeInfo.h = Y-SizeInfo.y;
	return SizeInfo;
}

var LoadSymbolAnim = -1;
function LoadSymbolAnimRestart()
{
	if(LoadSymbolAnim > 0)
	{
		LoadSymbolAnim += 1;
	}
	else
	{
		LoadSymbolAnim = 1;
	}
}
function LoadSymbolAnimUpdateAndGet()
{
	if(LoadSymbolAnim>=0)
	{
		LoadSymbolAnim -= 0.03;
		if(LoadSymbolAnim < 0)
		{
			LoadSymbolAnim = -1;
		}
		else
		{
			return Math.sin(3.14  * LoadSymbolAnim);
		}

	}
	return -1;
}


var CircleSteps = 30;
var CircleX = Array(CircleSteps);
var CircleY = Array(CircleSteps);
function InitCircle()
{
	var twopi = 2 * Math.PI;
	for(var i = 0; i < CircleSteps; ++i)
	{
		var s = (1.0*i) / CircleSteps;

		var f = (1.0 * s) * twopi;
		CircleX[i] = Math.sin(f);
		CircleY[i] = Math.cos(f);
	}
}
function SpinnerResize(Spinner, w, h)
{
	if(h != Spinner.CanvasH || w != Spinner.CanvasW || DPR != Spinner.CanvasDPR)
	{
		Spinner.Canvas.style.width = w + 'px';
		Spinner.Canvas.style.height = h + 'px';
		Spinner.Canvas.width = w * DPR;
		Spinner.Canvas.height = h * DPR;
		Spinner.Canvas.getContext('2d').scale(DPR, DPR);
		Spinner.CanvasBack.style.width = w + 'px';
		Spinner.CanvasBack.style.height = h + 'px';
		Spinner.CanvasBack.width = w * DPR;
		Spinner.CanvasBack.height = h * DPR;

		Spinner.CanvasBack.getContext('2d').scale(DPR, DPR);
		Spinner.CanvasH = h;
		Spinner.CanvasW = w;
		Spinner.CanvasDPR = DPR;
	}
}
function SpinnerCircle(Phase0, Shift0, Phase1, Shift1, Phase2, Shift2)
{
	return {"Phase0" : Phase0, "Shift0": Shift0, "Phase1":Phase1, "Shift1":Shift1, "Phase2": Phase2, "Shift2": Shift2, "Q": 0, "QQ": 0, "A0":0, "A1":0, "A2":0};
}

function SpinnerInit(Blur, Color)
{
	var Spinner = {};
	Spinner.x = 0;
	Spinner.y = 0;
	Spinner.Canvas = document.createElement('canvas');
	Spinner.CanvasBack = document.createElement('canvas');
	Spinner.CanvasOffscreenData;
	Spinner.CanvasW = -1;
	Spinner.CanvasH = -1;
	Spinner.CanvasDPR = -1;
	Spinner.Circles = [];
	var x = 1 / 4;
	var y = 0.07;
	Spinner.Circles.push(SpinnerCircle(x, 0, y, 0, 0.0, 0.25));
	Spinner.Circles.push(SpinnerCircle(2/4, 0, 0, 0, 0.14, 0.25));
	Spinner.Fade = 0;
	Spinner.Blur = Blur;
	Spinner.Color = Color;
	return Spinner;
}

var SpinnerCorner = SpinnerInit(0.8, 'white');
var SpinnerLoadButton = SpinnerInit(0, 'white');
var SpinnerText1 = SpinnerInit(0.0, 'red');
var SpinnerText0 = SpinnerInit(0.0, 'red');


function SpinnerShow()
{
	return SymbolState != null && (SymbolState.q == 1 || SymbolState.r != SymbolState.f || FunctionQueryLastRequest != FunctionQueryReceived);
}

function SpinnerDraw(Enable, context, Spinner, X, Y, w, h)
{
	SpinnerResize(Spinner, w, h);
	var ContextSpinner = Spinner.Canvas.getContext('2d');


	var now = Date.now();
	if(!ContextSpinner.last)
	{
		ContextSpinner.last = now;
	}
	var DT = now - ContextSpinner.last;
	ContextSpinner.last = now;
	if(Enable)
	{
		Spinner.Fade += DT / 200;
	}
	else
	{
		Spinner.Fade -= DT / 1000;
	}
	Spinner.Fade = Math.max(0, Spinner.Fade);
	Spinner.Fade = Math.min(1, Spinner.Fade);
	var F = Spinner.Fade * Spinner.Fade;

	if(Spinner.Fade <= 0)
		return;
	ContextSpinner.clearRect(0, 0, w, h);
	if(Spinner.Blur > 0)
	{
		ContextSpinner.globalAlpha = Spinner.Blur;
		ContextSpinner.drawImage(Spinner.CanvasBack, 0, 0, w, h);
		ContextSpinner.globalAlpha = 1.0;
	}
	var twopi = 2 * Math.PI;
	for(var jjj = 0; jjj < Spinner.Circles.length; ++jjj)
	{
		var C = Spinner.Circles[jjj];
		InitCircle();
		var xs = CircleX;
		var ys = CircleY;
		var scale = (w-2) / 2;
		var offset = (w) / 2;
		var SPEED = 100.0;

		var angle = (C.Q / SPEED) * twopi;

		var QQSPEED = 1000;

		C.A0 += (twopi * DT / 1000.0) * C.Phase0;
		if(C.A0 > twopi)
			C.A0 -= twopi;
		C.A1 += (twopi * DT / 1000.0) * C.Phase1;
		if(C.A1 > twopi)
			C.A1 -= twopi;
		C.A2 += (twopi * DT / 1000.0) * C.Phase2;
		if(C.A2 > twopi)
			C.A2 -= twopi;

		var A0 = C.A0 + twopi * C.Shift0;
		var A1 = C.A1 + twopi * C.Shift1;
		var A2 = C.A2 + twopi * C.Shift2;
		var m = Math.cos(A0);
		var m0 = Math.sin(A2);
		var cs = Math.cos(A1);
		var ss = Math.sin(A1);
		for(var i = 0; i < xs.length; ++i)
		{
			var x = xs[i] * m;
			var y = ys[i] * m0;
			xs[i] = cs * scale * x - ss * scale * y;
			ys[i] = ss * scale * x + cs * scale * y;
			xs[i] += offset;
			ys[i] += offset;
		}
		ContextSpinner.strokeStyle = Spinner.Color;
		ContextSpinner.beginPath();
		ContextSpinner.moveTo(xs[0], ys[0]);
		for(var i = 1; i < CircleSteps; ++i)
		{
			ContextSpinner.lineTo(xs[i], ys[i]);
		}
		ContextSpinner.lineTo(xs[0], ys[0]);
		ContextSpinner.stroke();


	}
	context.globalAlpha = F;
	context.drawImage(Spinner.Canvas, X, Y, w, h);
	context.globalAlpha = 1;
	var tmp = Spinner.CanvasBack;
	Spinner.CanvasBack = Spinner.Canvas;
	Spinner.Canvas = tmp;
}


function DrawMenuPatched()
{
	if(FilterInputValueLast != FilterInput.value)
	{
		nOffsetMenuPatched = 0;
	}

	var FilterArray = CreateFilter(FilterInput.value);
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = TimerMenuSize();
	SizeInfo.x = MenuItems[SubMenuPatched].x;
	SizeInfo.y = MenuItems[SubMenuPatched].y;
	var Y = SizeInfo.y;
	var Width = SizeInfo.w;
	Width = Math.max(300, Width);
	Width = 10+ MeasureArray(Width, FunctionsInstrumented, function(s, i){return s + " " + FunctionsInstrumentedModule[i];} );

	if(Width + SizeInfo.x + 50 > nWidth)
	{
		Width = nWidth - (SizeInfo.x+50);
	}
	SizeInfo.w = Width;
	var MaxStringLength = Math.floor(Width/(FontWidth));

	var Selection = null;
	var X = SizeInfo.x;
	context.fillStyle = nBackColors[0];
	TextY = Y+BoxHeight-FontAscent;
	context.fillRect(X, Y, Width, BoxHeight);

	var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight && MouseX-X < 100;
	context.fillRect(X, Y, 99, BoxHeight);
	context.textAlign = 'center';
	context.fillStyle = 'white';
	context.fillText("Patched functions", X + Width/2, TextY);

	Y += BoxHeight;
	MoveFilterInputDiv(SizeInfo.x, Y, SizeInfo.w-6);
	Y += 45;

	bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
	var TextY = Y+BoxHeight-FontAscent;
	var YClear = Y;
	var TextYClear = TextY;
	var bgcolorClear = bgcolor;
	var YStart = Y-BoxHeight*2;

	nColorIndex = 1-nColorIndex;

	Y -= nOffsetMenuFunctions + 10;
	var Selection = -1;

	var StringColor = function(Name)
	{
		var h = StringHash(Name);
		var cidx = h % 360;
		return cidx;
	};

	var GetColor = function(Str)
	{
		var cidx = StringColor(Str);
		return "hsl(" + cidx + ",50%, 70%)";
	};
	for(var i = 0; i < FunctionsInstrumented.length; ++i)
	{
		var Name = FunctionsInstrumented[i];
		var ModuleName = FunctionsInstrumentedModule[i];
		if(FilterMatch(FilterArray, ModuleName + " " + Name))
		{

			var Color = GetColor(Name);
			var ColorModule = GetColor(Name);
			if(Y >= YStart)
			{
				bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
				bgcolor = bMouseIn && MouseX > X ? nBackColorOffset : nBackColors[nColorIndex];
				TextY = Y+BoxHeight-FontAscent;

				context.fillStyle = bgcolor;
				context.fillRect(X, Y, Width, BoxHeight);
				context.fillStyle = Color;
				context.textAlign = 'right';
				context.fillText(Name, X + Width - 2, TextY);
				context.textAlign = 'left';
				context.fillStyle = ColorModule;
				context.fillText(ModuleName, X, TextY);
			}
			Y += BoxHeight;
			nColorIndex = 1-nColorIndex;
		}
	}
	context.textAlign = 'left';
	SizeInfo.h = Y-SizeInfo.y;
	return SizeInfo;
}


function DrawMenuModules()
{
	if(FilterInputValueLast != FilterInput.value)
	{
		nOffsetMenuModules = 0;
	}
	FilterInputValueLast = FilterInput.value;
	var M = ModuleState;
	var FilterArray = CreateFilter(FilterInput.value);
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = TimerMenuSize(); //broken, fix!

	SizeInfo.x = MenuItems[SubMenuModules].x;
	SizeInfo.y = MenuItems[SubMenuModules].y;
	var Y = SizeInfo.y;
	var Width = SizeInfo.w;
	Width = Math.max(300, Width);
	Width = 10+ MeasureArray(Width, M, function(s){return s.n + " " + s.s;} );

	if(Width + SizeInfo.x + 50 > nWidth)
	{
		Width = nWidth - (SizeInfo.x+50);
	}
	SizeInfo.w = Width;


	var MaxStringLength = Math.floor(Width/(FontWidth));


	var X = SizeInfo.x;
	DrawSymbolHeaderMenu(context, X, Y, Width);

	Y += BoxHeight;
	MoveFilterInputDiv(SizeInfo.x, Y, SizeInfo.w-6);
	Y += 45;

	let bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
	var TextY = Y+BoxHeight-FontAscent;
	var YClear = Y;
	var TextYClear = TextY;
	var bgcolorClear = bgcolor;
	var YStart = Y-BoxHeight*2;

	nColorIndex = 1-nColorIndex;

	Y -= nOffsetMenuModules + 10;
	var Selection = -1;

	var StringColor = function(Name)
	{
		var h = StringHash(Name);
		var cidx = h % 360;
		return cidx;
	};

	for(var i = 0; i < M.length; ++i)
	{
		var Name = M[i].n;
		var Count = M[i].s;
		var Prc = M[i].p;
		if(Prc<0||Prc>1)
			Prc = 0;
		let cidx = StringColor(Name);
		let Color = "hsl(" + cidx + ",50%, 70%)";
		let C1 = "hsl(" + cidx + ",30%, 40%)";
		var N = Name;
		if(N.length > MaxStringLength)
		{
			N = N.substring(N.length - MaxStringLength);
		}
		if(FilterMatch(FilterArray, Name))
		{

			if(Y >= YStart)
			{
				bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
				bgcolor = bMouseIn && MouseX > X ? nBackColorOffset : nBackColors[nColorIndex];
				TextY = Y+BoxHeight-FontAscent;

				context.fillStyle = bgcolor;
				context.fillRect(X, Y, Width, BoxHeight);
				if(Prc>0 && Prc <= 1)
				{
					context.fillStyle = C1;
					context.fillRect(X, Y, Prc*Width, BoxHeight);
				}
				context.fillStyle = 'white';
				context.textAlign = 'right';
				context.fillText(Count + '', X + Width - 2, TextY);
				context.textAlign = 'left';
				context.fillStyle = Color;
				context.fillText(N, X, TextY);
				if(bMouseIn)
				{
					Selection = i;
				}
			}
			Y += BoxHeight;
			nColorIndex = 1-nColorIndex;
		}
	}
	context.textAlign = 'left';
	if(Selection != -1 && MouseReleased)
	{
		WSSendMessage("L" + M[Selection].n);
	}
	SizeInfo.h = Y-SizeInfo.y;
	return SizeInfo;
}
function DrawSymbolHeaderMenu(context, X, Y, Width)
{
	context.fillStyle = nBackColors[0];
	let TextY = Y+BoxHeight-FontAscent;
	context.fillRect(X+100, Y, Width-100, BoxHeight);
	let bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight && MouseX-X < 100;
	if(bMouseIn)
	{
		context.fillStyle = nBackColorOffset;
	}

	context.fillRect(X, Y, 99, BoxHeight);


	let NumSymbols = 0;
	let SymbolStateString = "Load all";
	let SymbolButtonActive = 1;
	let SymbolSpinnerActive = 0;
	let FinishedSymbols = 0;
	if(SymbolState)
	{
		FinishedSymbols = SymbolState.f;
		var s = SymbolState.s;
		NumSymbols = SymbolState.l;
		SymbolButtonActive = 1;
		if(SymbolState.q == 1 || FunctionQueryLastRequest != FunctionQueryReceived)
		{
			SymbolStateString = "Querying";
			SymbolButtonActive = 0;
			SymbolSpinnerActive = 1;
		}
		else if(SymbolState.f != SymbolState.r)
		{
			SymbolButtonActive = 0;
			SymbolSpinnerActive = 1;
			SymbolStateString = "Loading";
		}
		else if(SymbolState.f == ModuleState.length)
		{
			SymbolButtonActive = 0;
			SymbolStateString = "Loaded";
		}
	}
	let LoadButtonAnimation  = LoadSymbolAnimUpdateAndGet();

	context.textAlign = 'right';
	context.fillStyle = 'white';
	context.fillText(NumSymbols + " Symbols " + FinishedSymbols + "/" + ModuleState.length + " Modules", X+Width-2, TextY);
	context.textAlign = 'center';

	if(LoadButtonAnimation>0)
	{
		var c = "hsl(0,0%," + (LoadButtonAnimation * 100)+"%)";
		context.fillStyle = c;
	}
	if(SymbolButtonActive)
	{
		if(bMouseIn && MouseReleased)
		{
			WSSendMessage("S"); //load symbols
		}
		context.fillText(SymbolStateString, X + 50, TextY);
	}
	else
	{
		context.fillStyle = 'grey';
		context.fillText(SymbolStateString, X + 50, TextY);
	}
	SpinnerDraw(SymbolSpinnerActive, context, SpinnerLoadButton, X+2, Y,  FontHeight, FontHeight );


}

function DrawMenuFunctions()
{
	if(FilterInputValueLast != FilterInput.value)
	{
		nOffsetMenuFunctions = 0;
		var m = FilterInput.value.trim();
		if(m != "")
		{
			if(SymbolState && SymbolState.r == SymbolState.f)
			{
				var Req = ++FunctionQueryLastRequest;
				var Q = "q" + Req + "x" + m;
				WSSendMessage(Q);
				FunctionQueryPending = null;
			}
			else
			{
				FunctionQueryPending = m;
				if(SymbolState) //wtf?
				{
					LoadSymbolAnimRestart();
				}
			}
		}
	}

	FilterInputValueLast = FilterInput.value;
	var FF = FunctionQueryArray;
	var FilterArray = CreateFilter(FilterInput.value);
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = TimerMenuSize(); //broken, fix
	SizeInfo.x = MenuItems[SubMenuFunctions].x;
	SizeInfo.y = MenuItems[SubMenuFunctions].y;
	var Y = SizeInfo.y;
	var Width = SizeInfo.w;
	Width = Math.max(300, Width);
	Width = 10+ MeasureArray(Width, FF, function(s){return s.n + " " + s.m;} );

	if(Width + SizeInfo.x + 50 > nWidth)
	{
		Width = nWidth - (SizeInfo.x+50);
	}
	SizeInfo.w = Width;
	var MaxStringLength = Math.floor(Width/(FontWidth));

	var Selection = null;
	var X = SizeInfo.x;

	{
		DrawSymbolHeaderMenu(context, X, Y, Width);
	}


	Y += BoxHeight;
	MoveFilterInputDiv(SizeInfo.x, Y, SizeInfo.w-6);
	Y += 45;

	let bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
	var TextY = Y+BoxHeight-FontAscent;
	var YClear = Y;
	var TextYClear = TextY;
	var bgcolorClear = bgcolor;
	var YStart = Y-BoxHeight*2;

	nColorIndex = 1-nColorIndex;

	Y -= nOffsetMenuFunctions + 10;
	var Selection = -1;

	var StringColor = function(Name)
	{
		var h = StringHash(Name);
		var cidx = h % 360;
		return cidx;
	};

	for(var i = 0; i < FF.length; ++i)
	{
		if(true)
		{
			var Name = FF[i].n;
			var ShortName = FF[i].sn;
			var Color = FF[i].c;
			var ColorModule = FF[i].cm;
			var ModuleName = FF[i].m;
			if(!Color || !ColorModule)
			{
				var cidx = StringColor(ShortName);
				FF[i].c = "hsl(" + cidx + ",50%, 70%)";
				FF[i].rgb = ConvertHslToRGB(cidx/ 360, 0.5, 0.7);
				var cidxModule = StringColor(ModuleName);
				FF[i].cm = "hsl(" + cidxModule + ",50%, 70%)";
				FF[i].rgbm = ConvertHslToRGB(cidxModule/ 360, 0.5, 0.7);
				Color = FF[i].c;
				ColorModule = FF[i].cm;
			}
			var UseAlt = 0;
			var N = UseAlt ? Name : ShortName;
			if(N.length > MaxStringLength)
			{
				N = N.substring(N.length - MaxStringLength);
			}
			var E = false;
			if(true)
			{

				if(Y >= YStart)
				{
					bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
					bgcolor = bMouseIn && MouseX > X ? nBackColorOffset : nBackColors[nColorIndex];
					TextY = Y+BoxHeight-FontAscent;

					context.fillStyle = bgcolor;
					context.fillRect(X, Y, Width, BoxHeight);
					context.fillStyle = Color;
					context.textAlign = 'right';
					context.fillText(N, X + Width - 2, TextY);
					context.textAlign = 'left';
					context.fillStyle = ColorModule;
					context.fillText(ModuleName, X, TextY);
					if(bMouseIn)
					{
						context.fillStyle = Color;
						var bgcolorin = bMouseIn && MouseX < X ? nBackColorOffset : nBackColors[nColorIndex];

						Selection = i;
						var W = context.measureText('>>').width;
						W = Math.max(W, BoxHeight) + 2;
						var Corner = X - W - 1;
						if(Corner < SizeInfo.x)
						{
							SizeInfo.w += SizeInfo.x - Corner;
							SizeInfo.x = Corner;
						}
						context.fillStyle = bgcolorin;
						context.fillRect(Corner, Y, W, BoxHeight);
						context.fillStyle = Color;
						context.textAlign = 'center';
						context.fillText(">>", Corner + Math.floor(W / 2), TextY);

						context.textAlign = 'left';
					}
				}
				Y += BoxHeight;
				nColorIndex = 1-nColorIndex;
			}
		}
	}

	context.textAlign = 'left';
	if(Selection != -1 && MouseReleased)
	{
		if(KeyShiftDown || MouseX < X)
		{
			WSSendMessage("I" + FF[Selection].a + ' ' + FF[Selection].rgb + ' ' + FF[Selection].m + '!' + FF[Selection].n);
		}
		else
		{
			WSSendMessage("i" + FF[Selection].a + ' ' + FF[Selection].rgb + ' ' + FF[Selection].m + '!' + FF[Selection].n);
		}
	}
	SizeInfo.h = Y-SizeInfo.y;
	return SizeInfo;
}

function DrawMenuGeneric(Elements, Active, OnClick, x, y, Elements2)
{
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	if(Elements2.length != Elements.length)
	{
		Elements2 = null;
	}

	var h = FontHeight * Elements.length;
	var w = 20;
	var w2 = 0;
	for(var i = 0; i < Elements.length; ++i)
	{
		var m = context.measureText(Elements[i]).width;
		w = w > m ? w : m;
		if(Elements2)
		{
			m = context.measureText(Elements2[i]).width;
			w2 = w2 > m ? w2 : m;
		}
	}
	w += 10 + w2;
	var SizeInfo = MenuSize(w);
	SizeInfo.x = x;
	SizeInfo.y = y;
	var X = x;
	var Y = y;


	for(var i = 0; i < Elements.length; ++i)
	{
		var Selected = Active == i;
		var Name = Elements[i];
		var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
		var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
		var TextY = Y+BoxHeight-FontAscent;
		context.fillStyle = Selected?'white':bgcolor;
		context.fillRect(X-2, Y, w+4, BoxHeight);
		context.fillStyle = bgcolor;
		context.fillRect(X, Y, w, BoxHeight);
		context.fillStyle = 'white';
		context.fillText(Name, X + 2, TextY);
		if(Elements2)
		{
			context.textAlign = "right";
			context.fillText(Elements2[i], X + w , TextY);
			context.textAlign = "left";
		}
		context.fillText(Name, X + 2, TextY);
		if(bMouseIn && MouseReleased)
		{
			OnClick(i, Name);
		}
		Y += BoxHeight;
		nColorIndex = 1-nColorIndex;
	}
	SizeInfo.h = Y - SizeInfo.y;
	return SizeInfo;
}

function DrawMenuGroup()
{
	if(FilterInputValueLast != FilterInput.value)
	{
		nOffsetMenuGroup = 0;
	}
	FilterInputValueLast = FilterInput.value;

	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var Selection = null;
	var SizeInfo = GroupMenuSize();
	SizeInfo.x = MenuItems[SubMenuGroup].x;
	SizeInfo.y = MenuItems[SubMenuGroup].y;
	var Y = SizeInfo.y;
	var X = SizeInfo.x;
	var Width = SizeInfo.w;
	var FilterArray = CreateFilter(FilterInput.value);
	MoveFilterInputDiv(SizeInfo.x-2, SizeInfo.y, SizeInfo.w-1);
	var YStart = Y+20;
	Y += 35;
	Y -= nOffsetMenuGroup;


	function DrawMenuElement(Selected, Name, color, Indent)
	{
		var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
		var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
		context.fillStyle = Selected?'white':bgcolor;
		context.fillRect(X-2, Y, Width+4, BoxHeight);
		context.fillStyle = bgcolor;
		context.fillRect(X, Y, Width, BoxHeight);
		context.fillStyle = color;
		if(!Indent) Indent = 0;
		context.fillText(Name, X + Indent*FontWidth, Y+BoxHeight-FontAscent);
		nColorIndex = 1-nColorIndex;
		Y += BoxHeight;
		return bMouseIn;
	}
	function DrawMenuRecursive(Index, Indent, categorymatch)
	{
		ProfileEnter("DrawMenuRecursive");
		var v = TimerArray[Index];
		if(v.idtype == TYPE_TIMER || v.idtype == TYPE_COUNTER)
		{
			return;
		}
		if(v.idtype == TYPE_GROUP && !categorymatch)
		{
			if(!FilterMatch(FilterArray, v.name))
			{
				return;
			}
		}
		var catmatch = 0;
		if(v.idtype == TYPE_CATEGORY)
		{
			if(FilterMatch(FilterArray, v.name))
			{
				catmatch = 1;
			}
		}
		var Closed = 0;
		if(Index > 0)
		{
			if(Y > YStart)
			{
				if(DrawMenuElement(v.e, v.name, v.color, Indent))
				{
					Selection = v.id;
				}
			}
			else
			{
				Y += BoxHeight;
			}
		}

		if(!Closed)
		{
			var ChildIndex = v.firstchild;
			while(ChildIndex != -1)
			{
				DrawMenuRecursive(ChildIndex, Indent + 1, catmatch);
				ChildIndex = TimerArray[ChildIndex].sibling;
			}
		}
		ProfileLeave();
	}
	DrawMenuRecursive(0, -1);
	if(Selection && MouseReleased)
	{
		WSSendMessage("c" + Selection);
	}
	SizeInfo.h = Y - SizeInfo.y;
	return SizeInfo;
}

function ShowMenu()
{
	if(!Settings.ViewCompressed)
		return true;
	else
	{
		var Time = new Date();
		var Delta = Time - MouseMoveTime;
		console.log('delta time is ' + Delta);
		return Delta < 2000;
	}
}

function DrawMenu()
{
	if(KeyZDown)
		return;
	//if(WSConnected && WS && WS.readyState == 1)
	{
		var context = CanvasDetailedView.getContext('2d');
		var nColorIndex = 0;
		var Y = 50;
		var Width = 300;
		var Selection = null;
		if(!ShowMenu())
		{
			return;
		}
		ProfileEnter("DrawMenu");
		DrawTopMenu();
		var MenuRect = WindowRect(0,0,nWidth,nHeight);
		if(SubMenuActive != -1)
		{
			MouseMoveTime = new Date();
		}
		if(SubMenuActive == SubMenuGroup)
		{
			MenuRect = DrawMenuGroup();
		}
		else if(SubMenuActive == SubMenuTimers)
		{
			MenuRect = DrawMenuTimer();
		}
		else if(SubMenuActive == SubMenuModules)
		{
			MenuRect = DrawMenuModules();
		}
		else if(SubMenuActive == SubMenuFunctions)
		{
			MenuRect = DrawMenuFunctions();
		}
		else if(SubMenuActive == SubMenuPatched)
		{
			MenuRect = DrawMenuPatched();
		}
		else if(SubMenuActive == SubMenuSettings)
		{
			MenuRect = DrawMenuSettings();
		}
		else if(SubMenuActive == SubMenuViews)
		{
			MenuRect = DrawMenuViews();
		}
		else if(SubMenuActive == SubMenuPresets)
		{
			MenuRect = DrawMenuPresets();
		}
		else if(SubMenuActive == SubMenuColumns)
		{
			MenuRect = DrawMenuColumns();
		}
		else if(SubMenuActive == SubMenuCapture)
		{
			MenuRect = DrawMenuCapture();
		}
		else if(SubMenuActive == SubMenuGraphSettings)
		{
			MenuRect = DrawMenuGraphSettings();
		}
		else if(SubMenuActive == SubMenuGraph)
		{
			MenuRect = DrawMenuGraph();
		}
		else if(SubMenuActive == SubMenuGraphMode)
		{
			MenuRect = DrawMenuGraphMode();
		}
		else if(SubMenuActive == SubMenuPresets2)
		{
			MenuRect = DrawMenuPresets2();
		}
		if(SubMenuActive != SubMenuGraph)
		{
			MouseInGraphButton = -1;
		}




		var Grow = 10;
		MenuRect.x -= Grow;
		MenuRect.y -= Grow;
		MenuRect.h += 2*Grow;
		MenuRect.w += 2*Grow;
		var MouseMoved = MouseX != SubMenuMouseX || MouseY != SubMenuMouseY;

		if(MouseInRect(MenuRect) || !MouseMoved)
		{
			SubMenuTimeout = new Date();
			SubMenuMouseX = MouseX;
			SubMenuMouseY = MouseY;
		}
		else
		{
			var Time = new Date() - SubMenuTimeout;
			var Dest = SubMenuTimeoutBase * 1000;
			if(Time > Dest)
			{
				EnableMenu(-1);
			}
		}
		if(0)//debugging of menu extents. dont delete
		{
			context.strokeStyle = 'red';
			context.beginPath();
			context.moveTo(MenuRect.x,MenuRect.y);
			context.lineTo(MenuRect.x + MenuRect.w,MenuRect.y);
			context.lineTo(MenuRect.x + MenuRect.w,MenuRect.y+MenuRect.h);
			context.lineTo(MenuRect.x,MenuRect.y+MenuRect.h);
			context.lineTo(MenuRect.x,MenuRect.y);
			context.stroke();
		}

		ProfileLeave();
	}
}
function HasVideoTrack()
{
	for(let i in CSVSetNames)
	{
		let Name = CSVSetNames[i];
		let Set = CSVSets[Name];
		if(Set.VideoValid)
		{
			return true;
		}
	}
}
function GetTimeFromIndex(Name, Index)
{
	let Set = CSVSets[Name];
	if(Set.VideoValid && Set.TimeData && Set.TimeData.length > Index)
	{
		return Set.TimeData[Index];
	}
	return null;
}

function GetTimeFromIndexArray(Index)
{
	let out = Array();
	for(let Name in CSVSets)
	{
		let Set = CSVSets[Name];
		if(Set.VideoValid && Set.TimeData && Set.TimeData.length > Index)
		{
			out.push(Set.TimeData[Index]);
		}
	}
	return out;
}

function FormatSeconds(seconds)
{
	let str = "";
	let minutes = Math.floor(seconds/60.0);
	seconds = seconds - minutes * 60;
	if(minutes > 0)
		str += '' + minutes + 'm:' + seconds.toFixed(2) + 's';
	else
		str += '' + seconds.toFixed(2) + 's';
	return str;
}


function DrawVideo()
{
	let ForceRedraw = false;
	let context = CanvasDetailedView.getContext('2d');
	let Videos = [];
	let w = [];
	let h = [];
	let total = 0;
	const DrawHeight = VideoTrackHeight;
	for(let i = 0; i < CSVSetNames.length; ++i)
	{
		if(i == (CSVActiveSet-1) || CSVActiveSet == 0)
		{
			let Name = CSVSetNames[i];
			let Set = CSVSets[Name];
			if(Set.VideoValid)
			{
				let v = Set.Video;
				let s = v.seekable;
				if(s.length > 0)
				{
					let endtime = 0;
					for(let i = 0; i < s.length; ++i)
					{
						let s0 = s.start(i);
						let s1 = s.end(i);
						endtime = s1;
					}
					let time = gMouseXPrc * endtime;
					if(AllowTime)
					{
						let RealTime = GetTimeFromIndex(Name, gMouseIndex);
						if(RealTime != null && RealTime >= 0)
						{
							time = RealTime;

						}
					}
					if(endtime > 0 && !v.seeking && time != Set.VideoSetTime)
					{
						v.playbackRate = 0;
						v.currentTime = time;
						Set.VideoSetTime = time;
					}
					let width = v.videoWidth;
					let height = v.videoHeight;

					let DrawWidth = DrawHeight * width / height;
					total += DrawWidth + 1;
					Videos.push(v);
					w.push(DrawWidth);
					h.push(DrawHeight);
					if(v.seeking)
					{
						RequestDraw();
					}
				}
				else
				{
					gGraphCSVInvalid = 1;
					RequestDraw();
				}
			}
		}
	}
	let DrawPosX = MouseX - total / 2;
	let DrawPosY = nHeight - DrawHeight;

	DrawPosX = Math.max(0, Math.min(nWidth-total, DrawPosX));
	let VideoScale = 1.0;
	if(KeyZDown)
	{
		VideoScale = Math.min(nWidth / total, (nHeight-DrawHeight) / DrawHeight);
		DrawPosX = 0;
		let RealDrawWidth = VideoScale * total;
		if(RealDrawWidth < nWidth)
			DrawPosX = (nWidth - RealDrawWidth) / 2;
		DrawPosY = nHeight - DrawHeight * VideoScale;
		VideoTrackHeightActive = DrawHeight * VideoScale; //used in drawgraph to adjust height of the graph shown
	}
	for(let i = 0; i < Videos.length; ++i)
	{
		let v = Videos[i];
		context.drawImage(v, DrawPosX, DrawPosY, VideoScale * w[i], VideoScale * h[i]);
		DrawPosX += VideoScale * w[i] + 1;
	}
}


function DrawActiveToolTip()
{
	if(KeyZDown)
		return;
	if(SubMenuActive == -1)
	{
        if(ToolTipTag)
        {
            DrawToolTip(ToolTipTag, CanvasDetailedView, MouseX, nHeight - FontHeight, 1);
            ToolTipTag = null;
        }
		if(ToolTipImmediate)
		{
			DrawToolTip(ToolTipImmediate, CanvasDetailedView, MouseX, MouseY, ToolTipImmediateColumns);
			ToolTipImmediate = null;
		}
		else if(ToolTipCallback)
		{
			var Strings = ToolTipCallback(CanvasDetailedView, MouseX, MouseY);
			if(Strings)
			{
				DrawToolTip(Strings, CanvasDetailedView, MouseX, MouseY, 2);
			}
		}

	}
	for(let i = 0; i < GraphSettings.NumGraphs; ++i)
	{
		if(RangeToolTips[i] && RangeToolTips[i].a)
		{
			let h = nHeight;
			if(HasVideoTrack())
				h -= VideoTrackHeight;

			let yoffset = -BoxHeight * (RangeToolTips[i].a.length / RangeToolTipColumns) / 2;
			DrawToolTip(RangeToolTips[i], CanvasDetailedView, nWidth, yoffset + (0.5 + i) * h / GraphSettings.NumGraphs, RangeToolTipColumns);

		}
	}
	ToolTipCallback = null;
}
let PendingDraw = 0;

function Draw()
{
	PendingDraw = 0;
	ProfileEnter("Total");

	if(Settings.ViewActive == VIEW_CSV || (WSConnected && WS && WS.readyState == 1))
	{
		DrawViews();
		DrawMessage();
		DrawVideo();
		DrawMenu();
	}
	else
	{
		var context = CanvasDetailedView.getContext('2d');
		context.clearRect(0, 0, nWidth, nHeight);
		DrawMessage();
	}

	DrawPlotf(CanvasDetailedView);

	DrawActiveToolTip();


	ProfileLeave();
	ProfileModeDraw(CanvasDetailedView);
	ProfileModeClear();


	PlotfClear();

	MouseReleased = false;
}
function RequestDraw()
{
	if(!PendingDraw)
	{
		PendingDraw = 1;
		requestAnimationFrame(Draw);
	}
}

function MeasureWidth(str)
{
	var context = CanvasDetailedView.getContext('2d');
	return context.measureText(str).width;
}

function AllocClearedArray(Size)
{
	var A = new Array(Size);
	for(var i = 0; i < Size; ++i)
	{
		A[i] = 0;
	}
	return A;
}
function PushIntoArray(A, v)
{
	A.shift();
	A.push(v);
}


function MouseDragPan()
{
	return MouseDragButton == 1 || MouseDragKeyShift;
}
function MouseDragSelectRange()
{
	return MouseDragState == MouseDragMove && (MouseDragButton == 3 || (MouseDragKeyShift&&MouseDragKeyCtrl));
}

function MouseHandleDrag()
{
	if(MouseDragTarget == CanvasDetailedView)
	{
		if(SubMenuActive == -1)
		{
			if(MouseDragSelectRange() && SubMenuActive == -1)
			{
				var xStart = MouseDragXStart;
				var xEnd = MouseDragX;
				if(xStart > xEnd)
				{
					var Temp = xStart;
					xStart = xEnd;
					xEnd = Temp;
				}
				if(xEnd - xStart > 1)
				{
					MouseDragActiveXStart = xStart;
					MouseDragActiveXEnd = xEnd;
					let xOffset = gOffset * gRangeMaxLen;
					let xRange = gRange * gRangeMaxLen;
					RangeSelect.Begin = xOffset + xRange * (xStart / nWidth);
					RangeSelect.End = xOffset + xRange * (xEnd / nWidth);
					RangeSelect.YBegin = 0;
					RangeSelect.YEnd = nHeight;

				}
			}
			else if(MouseDragPan())
			{
				var X = MouseDragX - MouseDragXLast;
				var Y = MouseDragY - MouseDragYLast;
				if(X)
				{

					var X = MouseDragX - MouseDragXLast;
					var Y = MouseDragY - MouseDragYLast;
					if(X)
					{
						gOffset += -X * gRange / nWidth;

						ClampRangeOffset();
						gGraphCSVInvalid = 1;
					}


					MouseDragActiveXStart += X;
					MouseDragActiveXEnd += X;
				}
			}
			else if(MouseDragKeyCtrl)
			{
				if(MouseDragY != MouseDragYLast)
				{
					ZoomGraph(MouseDragY - MouseDragYLast);
				}
			}
			if(Settings.ViewActive == VIEW_BAR)
			{
				if(MouseDragKeyShift || MouseDragButton == 1)
				{
					var X = MouseDragX - MouseDragXLast;
					var Y = MouseDragY - MouseDragYLast;
					nOffsetBarsY -= Y;
					nOffsetBarsX -= X;
					if(nOffsetBarsY < 0)
					{
						nOffsetBarsY = 0;
					}
					if(nOffsetBarsX < 0)
					{
						nOffsetBarsX = 0;
					}
				}
			}
			if(Settings.ViewActive == VIEW_COUNTERS)
			{
				if(MouseDragKeyShift || MouseDragButton == 1)
				{
					var Y = MouseDragY - MouseDragYLast;
					nOffsetCountersY -= Y;
					if(nOffsetCountersY < 0)
					{
						nOffsetCountersY = 0;
					}
				}
			}
		}
		else if(SubMenuActive == SubMenuTimers || SubMenuActive == SubMenuGroup || SubMenuActive == SubMenuFunctions)
		{
			if(MouseDragKeyShift || MouseDragButton == 1)
			{
				var Y = MouseDragY - MouseDragYLast;
				if(SubMenuActive == SubMenuTimers)
				{
					nOffsetMenuTimers -= Y;
					if(nOffsetMenuTimers < 0)
					{
						nOffsetMenuTimers = 0;
					}
				}
				else if(SubMenuActive == SubMenuFunctions)
				{
					nOffsetMenuFunctions -= Y;
					if(nOffsetMenuFunctions < 0)
					{
						nOffsetMenuFunctions = 0;
					}
				}
				else
				{
					nOffsetMenuGroup -= Y;
					if(nOffsetMenuGroup < 0)
					{
						nOffsetMenuGroup = 0;
					}
				}
			}
		}
	}
	MouseDragXLast = MouseDragX;
	MouseDragYLast = MouseDragY;
}
function MouseHandleDragEnd()
{
	if(MouseDragTarget == CanvasDetailedView)
	{

	}
}

function MouseHandleDragClick()
{
	if(SubMenuActive == -1)
	{
		if(nHoverCounter != -1)
		{
			if(TimerArray[nHoverCounter].firstchild != -1)
			{
				TimerArray[nHoverCounter].closed = !TimerArray[nHoverCounter].closed;
			}
			else
			{
				TimerArray[nHoverCounter].Expanded = !TimerArray[nHoverCounter].Expanded;
			}
			Draw(1);
		}
	}
	if(MouseInCaptureButton)
	{
		TriggerCapture();
	}
}

function MapMouseButton(event)
{
	if(event.button == 1 || event.which == 1)
	{
		return 1;
	}
	else if(event.button == 3 || event.which == 3)
	{
		return 3;
	}
	else
	{
		return 0;
	}
}

function MouseDragReset()
{
	MouseDragState = MouseDragOff;
	MouseDragTarget = 0;
	MouseDragKeyShift = 0;
	MouseDragKeyCtrl = 0;
	MouseDragButton = 0;
}
function MouseDragKeyUp()
{
	if((MouseDragKeyShift && !KeyShiftDown) || (MouseDragKeyCtrl && !KeyCtrlDown))
	{
		MouseHandleDragEnd();
		MouseDragReset();
	}
}
function MouseDrag(Source, Event)
{
	if(Source == MouseDragOff || (MouseDragTarget && MouseDragTarget != Event.target))
	{
		MouseDragReset();
		return;
	}

	var LocalRect = Event.target.getBoundingClientRect();
	MouseDragX = Event.clientX - LocalRect.left;
	MouseDragY = Event.clientY - LocalRect.top;
	if(MouseDragState == MouseDragMove)
	{
		var dx = Math.abs(MouseDragX - MouseDragXStart);
		var dy = Math.abs(MouseDragY - MouseDragYStart);
		if((Source == MouseDragUp && MapMouseButton(Event) == MouseDragButton) ||
			(MouseDragKeyCtrl && !KeyCtrlDown) ||
			(MouseDragKeyShift && !KeyShiftDown))
		{
			MouseHandleDragEnd();
			MouseDragReset();
			return;
		}
		else
		{
			MouseHandleDrag();
		}
	}
	else if(MouseDragState == MouseDragOff)
	{
		if(Source == MouseDragDown || KeyShiftDown || KeyCtrlDown)
		{
			MouseDragTarget = Event.target;
			MouseDragButton = MapMouseButton(Event);
			MouseDragState = MouseDragDown;
			MouseDragXStart = MouseDragX;
			MouseDragYStart = MouseDragY;
			MouseDragKeyCtrl = 0;
			MouseDragKeyShift = 0;

			if(KeyShiftDown || KeyCtrlDown)
			{
				MouseDragKeyShift = KeyShiftDown;
				MouseDragKeyCtrl = KeyCtrlDown;
				MouseDragState = MouseDragMove;
			}
		}
	}
	else if(MouseDragState == MouseDragDown)
	{
		if(Source == MouseDragUp)
		{
			MouseHandleDragClick();
			MouseDragReset();
		}
		else if(Source == MouseDragMove)
		{
			var dx = Math.abs(MouseDragX - MouseDragXStart);
			var dy = Math.abs(MouseDragY - MouseDragYStart);
			if(dx+dy>1)
			{
				MouseDragState = MouseDragMove;
			}
		}
	}
	MouseDragXLast = MouseDragX;
	MouseDragYLast = MouseDragY;
}


function MouseMove(evt)
{
    evt.preventDefault();
	var rect = evt.target.getBoundingClientRect();
	var x = evt.clientX - rect.left;
	var y = evt.clientY - rect.top;
	MouseX = x;
	MouseY = y;
	MouseMoveTime = new Date();
    MouseDrag(MouseDragMove, evt);
    RequestDraw();
}


function MouseSortClick()
{
	if(SubMenuActive == -1)
	{
		if(SortColumnMouseOverNext)
		{
			if(SortColumnMouseOverNext == Settings.SortColumnName)
			{
				Settings.SortColumnOrderFlip =  1 - Settings.SortColumnOrderFlip;
			}
			else
			{
				Settings.SortColumnOrderFlip = 0;
			}

			Settings.SortColumnName = SortColumnMouseOverNext;
			SortColumnMouseOverNext = null;
		}
	}
}


function MouseButton(bPressed, evt)
{
    evt.preventDefault();
	MouseReleased = !bPressed;
	MouseDrag(bPressed ? MouseDragDown : MouseDragUp, evt);
	if(!bPressed)
		MouseSortClick();
    RequestDraw();
}

function MouseOut(evt)
{
	MouseDrag(MouseDragOff, evt);
	KeyCtrlDown = 0;
	KeyShiftDown = 0;
	KeyZDown = 0;
	RequestDraw();
}
function ClampRangeOffset()
{
	if(gRange > 1)
	{
		gRange = 1;
	}
	gOffset = Math.max(0, gOffset);
	if(gOffset + gRange > 1)
	{
		gOffset = 1 - gRange;
	}
}

function ZoomGraph(nZoom)
{
	gGraphCSVInvalid = 1;
	let fOldRange = gRange;
	let nModDown = 0;
	if(nZoom>0)
	{
		gRange *= Math.pow(nModDown ? 1.40 : 1.03, nZoom);
	}
	else
	{
		let fNewDetailedRange = gRange / Math.pow((nModDown ? 1.40 : 1.03), -nZoom);
		if(fNewDetailedRange < 2.0/gRangeMaxLen) //100ns
			fNewDetailedRange = 2.0/gRangeMaxLen;
		gRange = fNewDetailedRange;
	}

	let fDiff = fOldRange - gRange;
	let fMousePrc = MouseX / nWidth;
	if(fMousePrc < 0)
	{
		fMousePrc = 0;
	}
	gOffset += fDiff * fMousePrc;
	ClampRangeOffset();
}

function MouseWheel(e)
{
    var e = window.event || e;
    let delta = (e.wheelDelta || e.detail * (-120));
	ZoomGraph((-4 * delta / 120.0) | 0);
	RequestDraw();
}

function KeyUp(evt)
{
	var k = evt.keyCode;
	var InputActive = SubMenuActive == SubMenuTimers || SubMenuActive == SubMenuGroup || SubMenuActive == SubMenuFunctions || SubMenuActive == SubMenuPatched || SubMenuActive == SubMenuModules;
	if(k == 72)
	{
		KeyHDown = 0;
		UpdateShowHelp();
	}
	if(k == 187)
	{
		gDrawFrame = 1 - gDrawFrame;
		gGraphCSVInvalid = 1;
		RangeInvalidate(RangeSelectState);
	}



	if(!InputActive)
	{
		if(k == 220)
		{
			ProfileMode = !ProfileMode;
		}
		if(k == 32)
		{
			CSVActiveSet = (CSVActiveSet + 1) % (CSVNumSets+1);
			gGraphCSVInvalid = 1;
			RangeInvalidate(RangeSelectState);

		}
	}
	if(k >= 49 && k < 49 + MAX_GRAPHS)
	{
		GraphSettings.NumGraphs = (k-49) + 1;
		gGraphCSVInvalid = 1;
		RangeInvalidate(RangeSelectState);
		WriteCookie();


	}
	if(k == 27)
	{
		if(FilterInput.value.trim() != "")
		{
			FilterInput.value = "";
		}
		else
		{
			EnableMenu(-1);
		}

		MouseDragActiveXStart = MouseDragActiveXEnd = -1;
		Settings.SortColumnName = "";
		RangeInvalidate(RangeSelect);
		for(let i = 0; i < MAX_GRAPHS; ++i)
			RangeToolTips[i] = {};

		ShowHelp(0);
	}

	if(evt.keyCode == 17)
	{
		KeyCtrlDown = 0;
		MouseDragKeyUp();
	}
	if(evt.keyCode == 16)
	{
		KeyShiftDown = 0;
		MouseDragKeyUp();
	}
	if(evt.keyCode == 90)
	{
		KeyZDown = 0;
	}
	if(evt.keyCode == 187)
	{
		for(let i in GraphSettings.Graphs)
		{
			let g =  GraphSettings.Graphs[i];
			for(let name in g)
				if(g[name] == 0)
					delete g[name];
		}
		let json = JSON.stringify(GraphSettings);
		navigator.clipboard.writeText("AddNamedPreset('Preset_Name', '" + json + "');");
		window.alert("Preset code for named preset copied to clipboard. insert above after --insert named presets here--");
	}
	gGraphCSVInvalid = 1;
	RequestDraw();
}

function KeyDown(evt)
{
	if(evt.keyCode == 72)
	{
		KeyHDown = 1;
		UpdateShowHelp();
	}
	if(evt.keyCode == 17)
	{
		KeyCtrlDown = 1;
		MouseDragKeyUp();
	}
	if(evt.keyCode == 16)
	{
		KeyShiftDown = 1;
		MouseDragKeyUp();
	}
	if(evt.keyCode == 90)
	{
		KeyZDown = 1;
	}
	gGraphCSVInvalid = 1;
	RequestDraw();

}


function SetupEvents()
{
	var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel"; //FF doesn't recognize mousewheel as of
	CanvasDetailedView.addEventListener('mousemove', MouseMove, false);
	CanvasDetailedView.addEventListener('mousedown', function(evt) { MouseButton(true, evt); });
	CanvasDetailedView.addEventListener('mouseup', function(evt) { MouseButton(false, evt); } );
	CanvasDetailedView.addEventListener('mouseout', MouseOut);
	CanvasDetailedView.addEventListener("contextmenu", function (e) { e.preventDefault(); }, false);
	CanvasDetailedView.addEventListener(mousewheelevt, MouseWheel, false);
	window.addEventListener('keydown', KeyDown);
	window.addEventListener('keyup', KeyUp);
	window.addEventListener('resize', ResizeCanvas, false);
}

function DrawToolTip(StringArray, Canvas, x, y, Columns)
{
	if(!ShowMenu())
	{
		return;
	}
	if(!Columns)
		Columns = 2;
	let colors;
	let a = StringArray;
	if(StringArray.c)
	{
		a = StringArray.a;
		colors = StringArray.c;
	}
	let context = Canvas.getContext('2d');
	context.font = Font;
	context.textAlign = "left";

	let WidthArray = Array(a.length);
	let WidthColumn = Array(Columns);
	let nHeight = 0;
	for(let i = 0; i < Columns; ++i)
		WidthColumn[i] = 0;

	for(var i = 0; i < a.length; i += Columns)
	{
		let Sum = 0;
		for(let j = 0; j < Columns; j++)
		{
			let w = context.measureText(a[i+j]).width;
			WidthArray[i+j] = w;
			WidthColumn[j] = Math.max(WidthColumn[j], w);
		}
		nHeight += BoxHeight;
	}
	let nMaxWidth = 0;
	for(let i = 0; i < Columns; ++i)
	{
		WidthColumn[i] += 10;
		nMaxWidth += WidthColumn[i];
	}
	//bounds check.
	x = Math.max(0, x - 10 - nMaxWidth);
	let CanvasRect = Canvas.getBoundingClientRect();
	if(y + nHeight > CanvasRect.height)
	{
		y = CanvasRect.height - nHeight;
		x += 20;
	}
	if(x + nMaxWidth > CanvasRect.width)
	{
		x = CanvasRect.width - nMaxWidth;
	}

	context.fillStyle = 'black';
	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
	context.fillStyle = 'white';

	var XPos = x;
	var XPosRight = x + nMaxWidth;
	var YPos = y + BoxHeight-2;
	context.fillStyle = 'white';
	for(i = 0; i < a.length; i += Columns)
	{
		let XLocal = XPos;
		for(let j = 0; j < Columns; ++j)
		{
			if(colors && colors[i+j])
				context.fillStyle = colors[i+j];
			else
				context.fillStyle = 'white';
			if(j == 0)
			{
				context.textAlign = "left";
				context.fillText(a[i+j], XLocal, YPos);
				XLocal += WidthColumn[j];
			}
			else
			{
				XLocal += WidthColumn[j];
				context.textAlign = "right";
				context.fillText(a[i+j], XLocal, YPos);
			}
		}
		YPos += BoxHeight;
	}
	context.fillStyle = 'white';
}

function DrawPlotf(Canvas)
{
	return;
	var context = Canvas.getContext('2d');
	context.font = Font;
	var WidthArray = Array(PlotfArray.length);
	var nMaxWidth = 0;
	var nHeight = 0;

	context.font = Font;
	for(i = 0; i < PlotfArray.length; i++)
	{
		var nWidth = context.measureText(PlotfArray[i]).width;
		WidthArray[i] = nWidth;
		if(nWidth > nMaxWidth)
		{
			nMaxWidth = nWidth;
		}
		nHeight += BoxHeight;
	}
	nMaxWidth += 15;
	var x = 0;
	var y = 0;

	context.fillStyle = 'black';
	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
	context.fillStyle = 'white';

	var XPos = x;
	var XPosRight = x + nMaxWidth;
	var YPos = y + BoxHeight-2;
	for(i = 0; i < PlotfArray.length; i++)
	{
		context.fillText(PlotfArray[i], XPos, YPos);
		YPos += BoxHeight;
	}
}


function ShiftRight10(v)
{
	if(v > 1024)
	{
		return v / 1024.0;
	}
	else
	{
		return v >> 10;
	}
}

function FormatCounter(Format, Counter)
{
	if(!Counter)
	{
		return '0';
	}
	var Negative = 0;
	if(Counter < 0)
	{
		Counter = -Counter;
		Negative = 1;
		if(Counter < 0) // handle INT_MIN
		{
			Counter = -(Counter+1);
			if(Counter < 0)
			{
				return '?';
			}
		}
	}
	var str = Negative ? '-' :'' ;
	if(Format == FormatCounterDefault)
	{
		var Seperate = 0;
		var result = '';
		while (Counter)
		{
			if (Seperate)
			{
				result += '.';
			}
			Seperate = 1;
			for (var i = 0; Counter && i < 3; ++i)
			{
				var Digit = Math.floor(Counter % 10);
				Counter = Math.floor(Counter / 10);
				result += '' + Digit;
			}
		}

		for(var i = 0; i < result.length; ++i)
		{
			str += result[result.length-1-i];
		}
		return str;
	}
	else if(Format == FormatCounterBytes)
	{
		var Shift = 0;
		var Divisor = 1;
		var CountShifted = ShiftRight10(Counter);
		while(CountShifted)
		{
			Divisor <<= 10;
			CountShifted = ShiftRight10(CountShifted);
			Shift++;
		}
		if(Shift)
		{
			return str + (Counter / Divisor).toFixed(2) + '' + FormatCounterBytesExt[Shift];
		}
		else
		{
			return str + Counter.toFixed(2) + '' + FormatCounterBytesExt[0];
		}
	}
	return '?';
}


function ShowHelp(Show, Toggle)
{
	var HelpWindow = document.getElementById('helpwindow');
	if(Toggle)
	{
		if(HelpWindow.style['display'] == 'block')
		{
			HelpWindow.style['display'] = 'none';
		}
		else
		{
			HelpWindow.style['display'] = 'block';
		}
	}
	else
	{
		if(Show)
		{
			HelpWindow.style['display'] = 'block';
		}
		else
		{
			HelpWindow.style['display'] = 'none';
		}
	}
}

function ParseUrl()
{
	var path = window.location.pathname;
	var idx = path.indexOf('/');
	if(idx < 0)
		return;
	var StrCommand = path.substring(idx+1);
	idx = StrCommand.indexOf('/');
	if(idx < 0)
		return;
	var StrSettings = StrCommand.substring(idx+1);
	PresetToLoad = StrSettings;
	PresetToLoadRO = StrCommand[0] == 'b';
}


function GetCookie()
{
	let cookie = localStorage.getItem("microprofile_csv");
	var result = cookie ? cookie.match(/fisk=([^;]+)/) : null;
	console.log(cookie);
	console.log(result);
	if(result && result.length > 0)
	{
		var Obj = JSON.parse(result[1]);
		if(!Obj.offline)
		{
			var C = {};
			C.offline = Obj;
			Obj = C;
		}
		return Obj;
	}
	else
	{
		return {offline:{},live:{},csv:{}};
	}
}

function ReadCookie()
{
	var C = GetCookie().csv;
	for(var i in C)
	{
		Cookie[i] = C[i];
	}
	if(Cookie.PresetsSets)
	{
		PresetSets = Cookie.PresetsSets;
		if(Cookie.GraphPresetIndex)
			GraphPresetIndex = Cookie.GraphPresetIndex;
		else
			GraphPresetIndex = 0;
		if(PresetSets[GraphPresetIndex])
			GraphSettings = PresetSets[GraphPresetIndex];
		else
		{
			PresetSets[GraphPresetIndex] = CreateDefaultGraphSettings();
		}

	}
	else if(Cookie.Graphs)
	{
		PresetSets[GraphPresetIndex] = CreateDefaultGraphSettings();
		for(let i = 0; i < Cookie.Graphs.length; ++i)
		{
			PresetSets[GraphPresetIndex].Graphs[i] = Cookie.Graphs[i];
		}
		if(Cookie.NumGraphs)
		{
			PresetSets[GraphPresetIndex].NumGraphs = Cookie.NumGraphs;
		}
	}
	GraphSettings = PresetSets[GraphPresetIndex];

}
function WriteCookie()
{
	Cookie.PresetsSets = PresetSets;
	Cookie.GraphPresetIndex = GraphPresetIndex;

	var C = GetCookie();


	Cookie.csv = {};
	delete Cookie.Graphs;


	for(var i in Cookie)
	{
		C.csv[i] = Cookie[i];
	}

	var date = new Date();
	date.setFullYear(2099);
	var cookie = 'fisk=' + JSON.stringify(C) + ';expires=' + date;
	localStorage.setItem("microprofile_csv", cookie);
}



// Shared graph code begin
let GRAPH_DRAW_FILLED = 1;
let GRAPH_DRAW_LINES = 2;
let GRAPH_DRAW_SECTION = 3;

function CreateGraph2Data(Samples, Name, Color, Mode, Samples2)
{
	let gd = {};
	let min = 1e38;
	let max = 0;
	gd.Samples = Samples;
	gd.Samples2 = Samples2;
	for(let i = 0; i < Samples.length; ++i)
	{
		if (isNaN(Samples[i])) continue;
		min = Math.min(min, Samples[i]);
		max = Math.max(max, Samples[i]);
	}
	if(Samples2)
	{
		for(let i = 0; i < Samples2.length; ++i)
		{
			if (isNaN(Samples2[i])) continue;
			min = Math.min(min, Samples2[i]);
			max = Math.max(max, Samples2[i]);
		}
	}
	gd.Min = min;
	gd.Max = max;
	gd.Name = Name;
	gd.Color = Color;
	gd.Mode = Mode;
	return gd;
}


function CreateDrawGraph2Parameters()
{
	let P = {};
	P.Rect = WindowRect(0, 0, 1, 1);
	P.RangeMin = 0.0;
	P.RangeMax = 0.0;
	P.Mark = [0.1, 1.0, 16.66, 33.33, 100, 1000, 10000, 100000, 1000000];
	P.Ext = "ms";
	P.Border = 2;
	P.Frame = 1;
	P.Digits = -1;
	P.DrawMode = GRAPH_DRAW_FILLED;
	P.xRange = 1;
	P.xOffset = 0;
	P.FullDraw = 1;
	P.MouseMarker = 0;
	P.ColorFront = '#59d0ff';
	P.ColorBack = '#00ddff';
	return P;
}

function DrawGraph2TextBox(context, text, x, y, align)
{
	let textsize = context.measureText(text).width;
	let offsetx = 0;
	let offsety = -FontHeight;
	if(align == 'center')
	{
		offsetx = -textsize / 2.0;
	}
	else if(align == 'right')
	{
		offsetx = -textsize;
	}
	context.fillStyle = nBackColors[0];
	context.fillRect(x + offsetx, y + offsety, textsize+2, FontHeight + 2);
	context.fillStyle = 'white';
	context.fillText(text, x, y);

}


function DrawGraph2Range(context, Params, Range, Name, Offset)
{
	if(!Offset)
		Offset = 0;
	var fBegin = Range.Begin;
	var fEnd = Range.End;
	var OffsetTop = Range.YBegin;
	var OffsetBottom = Range.YEnd;

	let xRange = gRange * gRangeMaxLen;
	let xOffset = gOffset * gRangeMaxLen;
	let ColorFront = Params.ColorFront;
	let ColorBack = Params.ColorBack;

	var Off = Range.Off + xOffset;
	if(fBegin < fEnd)
	{
		var MarginTop = (1.0+Offset) * (FontHeight+1);
		var MarginBottom = nHeight - (Offset+1.5) * (FontHeight+1);
		if(OffsetTop < MarginTop)
		{
			Offset += 1;
			OffsetTop = MarginTop;
		}
		if(OffsetBottom > MarginBottom)
		{
			OffsetBottom = MarginBottom;
		}
		var fRulerOffset = FontHeight * 0.5;
		var fScaleX = nWidth / xRange;
		var X = (fBegin - Off) * fScaleX;
		var YSpace = (FontHeight+2);
		var Y = OffsetTop;
		var YBottom = OffsetBottom;
		var W = (fEnd - fBegin) * fScaleX;
		context.globalAlpha = 0.1;
		context.fillStyle = ColorBack;
		context.fillRect(X, OffsetTop + fRulerOffset, W, OffsetBottom - OffsetTop);
		context.globalAlpha = 1;
		context.strokeStyle = ColorFront;
		context.beginPath();
		context.moveTo(X, 0);
		context.lineTo(X, nHeight);
		context.moveTo(X+W, 0);
		context.lineTo(X+W, nHeight);
		context.stroke();

		let Center = ((fBegin + fEnd) / 2.0) - Off;
		let TextLeft = Params.FormatIndex ? Params.FormatIndex(fBegin-Range.Off) : fBegin-Range.Off;
		let TextRight = Params.FormatIndex ? Params.FormatIndex(fEnd-Range.Off) : fEnd-Range.Off;
		let TextMid = Params.FormatRange ? Params.FormatRange(fBegin-Range.Off, fEnd-Range.Off) : Center;
		let TextCount = Math.max(Math.max(TextLeft.length, TextRight.length), TextMid.length);

		let MidWidth = 0;
		for(let t = 0; t < TextCount; ++t)
			if(TextMid[t])
				MidWidth = Math.max(MidWidth, context.measureText(TextMid[t]+ "   ").width);

		context.fillStyle = 'white';
		context.textAlign = 'right';
		let TextPosY = Y + YSpace;
		for(let t = 0; t < TextCount; ++t)
			if(TextLeft[t])
				DrawGraph2TextBox(context, TextLeft[t], X-3, TextPosY + t * FontHeight, 'right');
		let YS = [Y, YBottom];
		for(let i = 0; i < YS.length; ++i)
		{
			let Y = YS[i];
			let Y0 = Y + fRulerOffset;
			let W0 = W - MidWidth + FontWidth*1.5;
			if(W0 > 6)
			{
				context.textAlign = 'center';
				for(let t = 0; t < TextCount; ++t)
					if(TextMid[t])
						DrawGraph2TextBox(context, TextMid[t], Center * fScaleX, Y + YSpace + t * FontHeight, 'center');
				W0 = W0 / 2.0;
				let X0 = X + W0;
				let X1 = X + W - W0;
				context.strokeStyle = ColorFront;
				context.beginPath();
				context.moveTo(X, Y0);
				context.lineTo(X0, Y0);
				context.moveTo(X0, Y0-2);
				context.lineTo(X0, Y0+2);
				context.moveTo(X1, Y0-2);
				context.lineTo(X1, Y0+2);
				context.moveTo(X1, Y0);
				context.lineTo(X + W, Y0);
				context.stroke();
			}
			else
			{
				if(i == 1)
				{
					for(let t = 0; t < TextCount; ++t)
					{
						if(TextMid[t])
						{
							context.textAlign = 'right';
							DrawGraph2TextBox(context, TextMid[t], X - 3, Y0+t * FontHeight, 'right');
							context.textAlign = 'left';
							DrawGraph2TextBox(context, TextMid[t], X + W + 2, Y0+t * FontHeight, 'left');
						}
					}
				}
				context.strokeStyle = ColorFront;
				context.beginPath();
				context.moveTo(X, Y0);
				context.lineTo(X+W, Y0);
				context.stroke();
			}
		}
		context.textAlign = 'left';
		for(let t = 0; t < TextCount; ++t)
				if(TextRight[t])
					DrawGraph2TextBox(context, TextRight[t], X + W + 2, TextPosY + t * FontHeight, 'left');
	}
	return Offset;
}

function Graph2MouseXPrc(Parameters, Mouse)
{
	let Rect = Parameters.Rect;
	let Ext = Parameters.Ext;
	let Border = Parameters.Border;
	let Frame = Parameters.Frame;
	if(Frame)
		Border += 10;
	let x = Rect.x + Border;
	let y = Rect.y + Border;
	let h = Rect.h - 2*Border;
	let w = Rect.w - 2*Border;

	let MouseX = Mouse.X-x;
	let MouseY = Mouse.Y-y;
	let MouseXPrc = (Mouse.X - x) / (w-1);
	return Math.max(0.0, Math.min(1.0, MouseXPrc));
}

function DrawGraph2(context, Parameters, data, Mouse, OutMouseIndex)
{
	ProfileEnter("DrawGraph2");
	let Rect = Parameters.Rect;
	let RangeMin = Parameters.RangeMin;
	let RangeMax = Parameters.RangeMax;
	let xRangeFloat = Parameters.xRange;
	let xOffsetFloat = Parameters.xOffset;
	let FullDraw = Parameters.FullDraw;
	let MaxLen = 0;
	let MaxSample = 0;
	let MinSample = 1e25;
	let xOffset = 0;
	let xRange = 0;
	let MouseIndexResult = -1;


	for(let i in data)
	{
		let d = data[i];
		if(MaxLen == 0)
		{
			MaxLen = d.Samples.length;
			if(xRangeFloat >= 1.0)
			{
				xOffset = 0;
				xRange = MaxLen;
			}
			else
			{
				xOffset = Math.floor(xOffsetFloat * MaxLen);
				xRange = Math.floor(xRangeFloat * MaxLen);
			}

		}
		if(!d.Samples.length == MaxLen)
			debugger;
		MaxLen = Math.max(MaxLen, d.Samples.length);
		gRangeMaxLen = MaxLen;
		if(d.Samples2)
		{
			if(!d.Samples2.length == MaxLen)
				debugger;
		}

		//calc rangemin/max only on change
 		if(xOffset != 0 || xRange != MaxLen)
 		{
			if(!d.RangeMinMax || d.RangeMinMax.Offset != xOffset || d.RangeMinMax.Range != xRange)
			{
				d.RangeMinMax = {};
				d.RangeMinMax.Offset = xOffset;
				d.RangeMinMax.Range = xRange;
				let LocalMax = 0;
				let LocalMin = 1e25;
				for(let i = 0; i < xRange; ++ i)
				{
					LocalMax = Math.max(LocalMax, d.Samples[i + xOffset]);
					LocalMin = Math.min(LocalMin, d.Samples[i + xOffset]);
					if(d.Samples2)
					{
						LocalMax = Math.max(LocalMax, d.Samples2[i + xOffset]);
						LocalMin = Math.min(LocalMin, d.Samples2[i + xOffset]);
					}
				}
				d.RangeMinMax.LocalMin = LocalMin;
				d.RangeMinMax.LocalMax = LocalMax;
			}
			MaxSample = Math.max(d.RangeMinMax.LocalMax, MaxSample);
			MinSample = Math.min(d.RangeMinMax.LocalMin, MinSample);
 		}
 		else
 		{
			MaxSample = Math.max(d.Max, MaxSample);
			MinSample = Math.min(d.Min, MinSample);
 		}
	}
	if(0 == MaxLen)
		return;

	if(RangeMax <= RangeMin)
	{
		RangeMin = MinSample;
		RangeMax = MaxSample;
	}
	RangeMin = 0;


	let Ext = Parameters.Ext;
	let Border = Parameters.Border;
	let Frame = Parameters.Frame;
	if(Frame)
		Border += 10;

	let wx = Rect.x;
	let wy = Rect.y;
	let wh = Rect.h;
	let ww = Rect.w;

	let x = Rect.x + Border;
	let y = Rect.y + Border;
	let h = Rect.h - 2*Border;
	let w = Rect.w - 2*Border;

	let MouseX = Mouse.X-x;
	let MouseY = Mouse.Y-y;
	let MouseInside = Mouse.X >= x && Mouse.Y >= y && Mouse.X < x + w && Mouse.Y < y + h;
	let MouseXPrc = (Mouse.X - x) / (w-1);
	if(FullDraw)
	{
		context.clearRect(wx, wy, ww, wh);
	}

	if(Parameters.MouseMarker)
	{
		context.fillStyle = 'wheat';
		context.strokeStyle = 'wheat';
		context.globalAlpha = 0.1;
		context.beginPath();
		context.moveTo(Mouse.X, y);
		context.lineTo(Mouse.X, y+h);
		context.moveTo(x, Mouse.Y);
		context.lineTo(x+w, Mouse.Y);
		context.stroke();
		context.globalAlpha = 1;
	}


	let SampleWidth = w / (xRange-1);
	let MouseIndex = Math.max(0, Math.min(MaxLen-1, xOffset + Math.floor(MouseXPrc * xRange)));

	let HeightScale = h / (RangeMax-RangeMin);
	let Y = y + h;
	let YStart = Y;
	let GRAPH_ALPHA = 0.2;
	let SECTION_ALPHA = 0.3;
	let MouseDrawX;



	for(let dataindex in data)
	{
		let LocalElement = data[dataindex];
		let Samples = LocalElement.Samples;
		let Samples2 = LocalElement.Samples2;
		let Mode = LocalElement.Mode;
		let X = x + w - (xRange-1)*SampleWidth;
		Y = y + h;

		context.globalAlpha = 1;
		context.strokeStyle = LocalElement.Color;
		context.fillStyle = LocalElement.Color;
		if(FullDraw)
		{
			context.beginPath();
			for(let i = 0; i < xRange; ++i)
			{
				let idx = xOffset + i;
				Y = Math.max(YStart - Samples[idx] * HeightScale, y);
				if(i == 0)
					context.moveTo(X, Y);
				else
					context.lineTo(X, Y);
				X += SampleWidth;

			}

			if(Mode == GRAPH_DRAW_SECTION)
			{
				if(!Samples2)
					debugger;
				let len = Samples2.length;
				for(let i = 0; i < xRange; ++i)
				{
					X -= SampleWidth;
					let I = xOffset + xRange - i - 1;
					Y = Math.max(YStart - Samples2[I] * HeightScale, y);
					context.lineTo(X, Y);
				}
				context.globalAlpha = SECTION_ALPHA;
				context.fill();
			}
			else
			{
				context.stroke();
				context.lineTo(X-SampleWidth, YStart);
				context.lineTo(x, YStart);
				if(Mode == GRAPH_DRAW_FILLED)
				{
					context.globalAlpha = GRAPH_ALPHA;
					context.fill();
				}
			}
		}
		else
		{
			if(MouseInside && Mode != GRAPH_DRAW_SECTION)
			{
				let MouseSample = Samples[MouseIndex];
				let Y = Math.max(YStart - MouseSample * HeightScale, y);
				let X = x + w + (MouseIndex - (xOffset + xRange-1))*SampleWidth;
				MouseDrawX = X;

				context.globalAlpha = 0.8;
				context.beginPath();
				context.arc(X, Y, 2, 0, 2 * Math.PI);
				context.fill();

				context.globalAlpha = 1;

				context.beginPath();
				context.arc(X, Y, 3, 0, 2 * Math.PI);
				context.stroke();
			}
		}

	}
	context.globalAlpha = 1;
	context.fillStyle = 'wheat';
	context.strokeStyle = 'wheat';
	context.textAlign='right';

	if(FullDraw)
	{
		context.fillText(FormatNumber(RangeMax, Parameters.Digits) + Ext, x+w, y + FontHeight);
		for(let m in Parameters.Mark)
		{
			let Sample = Parameters.Mark[m];
			let Y = YStart - Sample * HeightScale;
			if(Sample < MaxSample && Sample > 0.1 * MaxSample)
			{
				context.globalAlpha = 1.0;
				context.fillText(Sample + Ext, x+w, Y + FontHeight);
				context.globalAlpha = 0.4;

				context.beginPath();
				context.moveTo(x-(Frame?5:0), Y);
				context.lineTo(x+w, Y);
				context.stroke();

			}
		}
		context.globalAlpha = 0.4;
		context.beginPath();
		context.moveTo(x-5, YStart-h);
		context.lineTo(x+w, YStart-h);
		context.stroke();

		context.globalAlpha = 1;

		if(Frame)
		{
			context.beginPath();
			context.moveTo(x-5, YStart);
			context.lineTo(x+w+5, YStart);
			context.stroke();



			context.beginPath();
			context.moveTo(x, YStart+5);
			context.lineTo(x, YStart-h-5);
			context.stroke();

			context.beginPath();
			context.moveTo(x, YStart-h);
			context.lineTo(x-5, YStart-h);
			context.stroke();


			context.textAlign= "right";
			let TextRight = Parameters.IndexDesc ? Parameters.IndexDesc(xRange+xOffset) : (xRange+xOffset) + '';
			let TextMouse = Parameters.IndexDesc ? Parameters.IndexDesc(MouseIndex) : (MouseIndex) + '';
			let TextLeft = Parameters.IndexDesc ? Parameters.IndexDesc(xOffset) : (xOffset) + '';

			context.fillText(TextRight, x+w, YStart+FontHeight);
			if(MouseDrawX)
			{
				context.textAlign= "center";
				let rect = context.measureText(TextMouse);
				let TextX = MouseDrawX;
				TextX = Math.max(TextX, x + 0.5 * rect.width);
				TextX = Math.min(TextX, w - 0.5 * rect.width);
				context.clearRect(TextX - 0.5 * rect.width ,1+ YStart, rect.width, FontHeight);
				context.fillText(TextMouse, TextX, YStart+FontHeight);
			}

			context.textAlign= "left";
			context.fillText(TextLeft, x+2, YStart+FontHeight);
		}


		let localindex = 0;
		for(let dataindex = 0; dataindex < data.length; ++dataindex)
		{
			let LocalElement = data[dataindex];
			if(LocalElement.Mode != GRAPH_DRAW_SECTION)
			{
				context.textAlign='left';
				context.strokeStyle = LocalElement.Color;
				context.fillStyle = LocalElement.Color;
				context.fillText(LocalElement.Name, x+2, y + FontHeight * (localindex+1));
				localindex++;
			}
		}

	}
	else
	{
		if(Frame)
		{
			if(MouseDrawX)
			{
				context.textAlign= "center";
				let TextMouse = Parameters.IndexDesc ? Parameters.IndexDesc(MouseIndex) : (MouseIndex) + '';
				let rect = context.measureText(TextMouse);
				let TextX = MouseDrawX;
				TextX = Math.max(TextX, x + 0.5 * rect.width);
				TextX = Math.min(TextX, ww - 0.5 * rect.width);
				context.clearRect(TextX - 0.5 * rect.width ,1+ YStart, rect.width, FontHeight);
				context.fillText(TextMouse, TextX, YStart+FontHeight);
			}
		}
		if(MouseInside)
		{
			MouseIndexResult = MouseIndex;
		}
	}

	ProfileLeave();
	return MouseIndexResult;
}
// Shared graph code end


function CreateCSVSetFile(Set, Filename)
{
	let File = {};
	File.Name = Filename;
	File.DataSorted = [];
	File.Data = [];
    File.Tags = [];
	File.ColumnToIndex = {};
	File.ColumnsSorted = {};
	File.Columns = {};

	return File;

}
function CreateCSVSet()
{
	let Index = ++CSVIndex;
	let Name = "Set_" + Index;
	let Set = {};
	Set.Name = Name;
	Set.Files = {};
	Set.Columns = {};
	Set.ColumnNames = {};
	Set.GraphDataMin = {};
	Set.GraphDataMax = {};
	Set.GraphDataAvg = {};
	Set.GraphDataSect = {};
	Set.GraphDataPercentileAvg = {};
	Set.GraphDataPercentileMin = {};
	Set.GraphDataPercentileMax = {};
	Set.GraphDataPercentileSect = {};
	Set.ColumnIndex = 0;
	Set.PendingCount = 0;
	Set.FinishedCount = 0;
	Set.TimeData = null;
	Set.Ready = false;
	return Set;
}
function EnlargeArray(a, size)
{
	let count = size - a.length;
	if(count < 0)
		debugger;
	let A = new Array();
	for(let i = 0; i < count; ++i)
		A.push(0);
	for(let i = 0; i < a.length; ++i)
	{
		A.push(a[i]);
	}
	return A;
}

function EnlargeAllArrays(set)
{
	for(let name in set)
	{
		let data = set[name];
		data.Samples = EnlargeArray(data.Samples, CSVMaxLength);
		if(data.Samples2)
			data.Samples2 = EnlargeArray(data.Samples2, CSVMaxLength);

	}
}

function ParseCSVCheckFinished(Name)
{
	let Set = CSVSets[Name];

	console.log("Finished parsing ", Set.FinishedCount, ":", Set.PendingCount);
	if(Set.FinishedCount == Set.PendingCount)
	{
		if(Set.FinishedCount == 0)
		{
			console.error("No CSV files were parsable");
			CSVSets[Name] = null;
		}
		else
		{
			let MaxCount = CSVMaxLength;
			//find the max column length
			for(let F in Set.Files)
			{
				let File = Set.Files[F];
				for(let CName in File.Columns)
					if(File.Columns[CName])
						MaxCount = Math.max(MaxCount, File.Columns[CName].length);
			}
			CSVMaxLength = MaxCount;
			for(let F in Set.Files)
			{
				let File = Set.Files[F];
				for(let CName in File.Columns)
					if(File.Columns[CName])
						if(File.Columns[CName].length < MaxCount)
						{
							File.Columns[CName] = EnlargeArray(File.Columns[CName], MaxCount);
						}
			}


			for(let CName in Set.ColumnNames)
			{
				CSVAllColumns[CName] = 1;
				let aggr = {};
				let count = new Array(MaxCount);
				let sum = new Array(MaxCount);
				let min = new Array(MaxCount);
				let max = new Array(MaxCount);
				let avg = new Array(MaxCount);
				let min_perc = new Array(MaxCount);
				let max_perc = new Array(MaxCount);
				let avg_perc = new Array(MaxCount);
				for(let i = 0; i < MaxCount; ++i)
				{
					count[i] = 0;
					sum[i] = 0;
					min[i] = 1e28;
					max[i] = -1e28;
				}
				for(let F in Set.Files)
				{
					let File = Set.Files[F];
					if(File.Columns[CName])
					{
						let c = File.Columns[CName];
						for(let i = 0; i < c.length; ++i)
						{
							count[i]++;
							sum[i] += c[i];
							min[i] = Math.min(c[i], min[i]);
							max[i] = Math.max(c[i], max[i]);

						}
					}
				}
				for(let i = 0; i < MaxCount; ++i)
				{
					if(count[i])
					{
						avg[i] = sum[i] / count[i];
					}
					else
					{
						min[i] = 0;
						max[i] = 0;
					}
				}
				for(let i = 0;i < MaxCount; ++i)
				{
					min_perc[i] = min[i];
					max_perc[i] = max[i];
					avg_perc[i] = avg[i];
				}
				let comp = function(l, r){ return l-r;};

				min_perc.sort(comp);
				max_perc.sort(comp);
				avg_perc.sort(comp);

				let name = CName;
				let FullName = Name + "/"+ CName;
				let color0 = ColorFromString(FullName, 70,  60);
				let color1 = ColorFromString(FullName, 80,  60);
				let color2 = ColorFromString(FullName, 80,  30);
				Set.GraphDataMin[CName] = CreateGraph2Data(min, FullName, color0, GRAPH_DRAW_LINES);
				Set.GraphDataMax[CName] = CreateGraph2Data(max, FullName, color0, GRAPH_DRAW_LINES);
				Set.GraphDataAvg[CName] = CreateGraph2Data(avg, FullName, color1, GRAPH_DRAW_LINES);
				Set.GraphDataSect[CName] = CreateGraph2Data(max, FullName, color0, GRAPH_DRAW_SECTION, min);
				Set.GraphDataPercentileAvg[CName] = CreateGraph2Data(avg_perc, FullName, color0, GRAPH_DRAW_LINES);
				Set.GraphDataPercentileMin[CName] = CreateGraph2Data(min_perc, FullName, color0, GRAPH_DRAW_LINES);
				Set.GraphDataPercentileMax[CName] = CreateGraph2Data(max_perc, FullName, color0, GRAPH_DRAW_LINES);
				Set.GraphDataPercentileSect[CName] = CreateGraph2Data(max_perc, FullName, color0, GRAPH_DRAW_SECTION, min_perc);

			}

			for(let SetName in CSVSets)
			{
				let Set = CSVSets[SetName];
				EnlargeAllArrays(Set.GraphDataMin);
				EnlargeAllArrays(Set.GraphDataMax);
				EnlargeAllArrays(Set.GraphDataAvg);
				EnlargeAllArrays(Set.GraphDataSect);
				EnlargeAllArrays(Set.GraphDataPercentileAvg);
				EnlargeAllArrays(Set.GraphDataPercentileMin);
				EnlargeAllArrays(Set.GraphDataPercentileMax);
				EnlargeAllArrays(Set.GraphDataPercentileSect);
			}


			//enable some default graphs
			let GraphIndex = 0;
			let first = 1;
			for(let Column in CSVAllColumns)
			{
				if(first)
				{
					first = 0;
					continue;
				}
				let gs = GraphSettings.Graphs[GraphIndex++];
				if(Object.keys(gs).length == 0)
				{
					gs[Column] = 1;
				}
				if(GraphIndex >= MAX_GRAPHS)
					break;
			}
			Set.Ready = true;
			gGraphCSVInvalid = 1;
			RangeInvalidate(RangeSelectState);
			ActivateView(VIEW_CSV);
			RequestDraw();
		}
	}
}

function ParseTagLine(Line)
{
    if(Line[0] == '#')
        return Line.slice(1, Line.length).trim();
    return null;
}
function ParseCSVLine(Line)
{
	let Pos = 0;
	let Start = 0;
	let Len = Line.length;
	let InBrackets = 0;
	let Out = new Array();
	let BracketStart = -1;
	let BracketEnd = -1;
	let push = function()
	{
		if(BracketStart >= 0)
		{
			console.assert(BracketEnd >= 0);
			Out.push(Line.slice(BracketStart+1, BracketEnd));
		}
		else
		{
			Out.push(Line.slice(Start, Pos).trim());

		}
		Start = Pos+1;
		InBrackets = 0;
		BracketStart = -1;
		BracketEnd = -1;
	};
	while(Pos != Len)
	{
		let Char = Line[Pos];
		if(InBrackets)
		{
			if(Char == "\"")
			{
				BracketEnd = Pos;
				InBrackets = 0;
			}
		}
		else
		{
			if(Char == "\"")
			{
				BracketStart = Pos;
				InBrackets = 1;
			}
			else if(Char == ",")
			{
				push();
			}
		}
		Pos++;
	}
	push();
	return Out;

}

function ParseCSVFile(Set, Result, Name)
{
	let File = CreateCSVSetFile(Set, Name);
	let Lines = Result.split(/\r?\n/);
	let Headers, Data, DataSorted, Tags;
	let TimeColumn = -1;
	let FrameTimeColumn = -1;
	let Columns = 0;
    let CurrentTag = null;
	for(let i = 0; i < Lines.length; ++i)
	{
        let Tag = ParseTagLine(Lines[i]);
        if(Tag){
            CurrentTag = Tag;
            continue;
        }

		let LineData = ParseCSVLine(Lines[i]);
		if(i == 0)
		{
			Headers = LineData;
			Columns = Headers.length;

			Data = new Array(Columns);
            Tags = new Array();
			DataSorted = new Array(Columns);
			File.Data = Data;
            File.Tags = Tags;
			File.DataSorted = DataSorted;
			for(let j = 0; j < Columns; ++j)
			{
				Data[j] = new Array();
				DataSorted[j] = new Array();

				let ColumnName = Headers[j];
				if(ColumnName.toLowerCase() == "time")
					TimeColumn = j;
				if(ColumnName.toLowerCase() == "frametime")
					FrameTimeColumn = j;
				File.ColumnToIndex[Headers[j]] = j;
				File.Columns[ColumnName] = Data[j];
				File.ColumnsSorted[ColumnName] = DataSorted[j];
				Set.ColumnNames[ColumnName] = 1;
			}
		}
		else
		{
			if(LineData.length != Columns)
			{
				console.log("Skipping line '" + Lines[i] + "'");
				continue;
			}
			for(let j = 0; j < Columns; ++j)
			{
				Data[j].push(parseFloat(LineData[j]));
				DataSorted[j].push(parseFloat(LineData[j]));
			}
            Tags.push(CurrentTag);
		}
	}
	let cmp = function(a,b){return a-b;}
	for(let j = 0; j < Columns; ++j)
	{
		DataSorted[j].sort(cmp);

	}
	if(TimeColumn >= 0 && AllowTime)
	{
		let TimeData = Data[TimeColumn];
		let TimeDataSorted = DataSorted[TimeColumn];
		let fail = false;
		for(let i = 0; i < TimeData.length; ++i)
		{
			if(TimeData[i] != TimeDataSorted[i])
			{
				fail = true;
				break;
			}
		}
		if(fail)
		{
			console.log("time row not ascending, ignoring");
		}
		else
		{
			if(!Set.TimeData || Set.TimeData.length < TimeData.length)
				Set.TimeData = Data[TimeColumn]; // note: only one time used per set
		}
	}
	else if(FrameTimeColumn >= 0 && AllowTime)
	{
		let FrameTimeData = Data[FrameTimeColumn];
		let TimeData = new Array(FrameTimeData.length);
		let time = 0;
		for(let i = 0; i < FrameTimeData.length; ++i)
		{
			TimeData[i] = time;
			time += FrameTimeData[i] / 1000.0
		}
		if(!Set.TimeData || Set.TimeData.length < FrameTimeData.length)
			Set.TimeData = TimeData; // note: only one time used per set
	}

	Set.Files[Name] = File;
    if(!Set.Tags)
        Set.Tags = File.Tags; // can only show tags fromt he first file in a set
	Set.FinishedCount++;
	ParseCSVCheckFinished(Set.Name);

}

function ReadCSVFile(Set, File)
{
	if(!File)
		return;
	let Reader = new FileReader();
	Reader.onload = function(e) {
		let t0 = new Date();
		ParseCSVFile(Set, e.target.result, File.name);
		let t1 = new Date();
		console.log("Parsing took ", (t1-t0).toFixed(2));
	};
	Reader.onprogress = function(e)
	{
		let m = e.loaded + ":" + e.total + " :: " + e.lengthComputable;
		console.log(m);
	};
	Set.PendingCount++;
	Reader.readAsText(File);

}

function UpdateShowHelp(ForceShow)
{
	if(ForceShow || KeyHDown)
	{
	    document.querySelector(".dropzone").style.visibility = "";
	    document.querySelector(".dropzone").style.opacity = 1;
	}
	else
	{
        document.querySelector(".dropzone").style.visibility = "hidden";
        document.querySelector(".dropzone").style.opacity = 0;
	}
}

// magic from stack-overflow somewhere..
function WindowDragEnter(e)
{
    LastDropTarget = e.target;
    UpdateShowHelp(1);
};


function WindowDragLeave(e)
{
    if(e.target === LastDropTarget || e.target === document)
    {
    	UpdateShowHelp(0);
    }
};

function ReadMp4File(Set, File)
{
	if(!Set.Video)
	{
		let v = document.createElement('Video');
		Set.Video = v;
		v.file = File;
		v.autoplay = true;
		v.preload = 'auto';
		v.muted = true;
		let reader = new FileReader();
		reader.onload = function(e) {
			v.src = e.target.result;
			Set.VideoValid = true;
			gGraphCSVInvalid = 1;
			RequestDraw();
			console.log("loaded Video");
		};
		reader.readAsDataURL(File);
	}
}

function DropHandler(ev)
{
	UpdateShowHelp(0);
	LastDropTarget = null;
	let VideoAlert = false;
	let CsvCount = 0;
	let Mp4Count = 0;
	for(let i = 0; i < ev.dataTransfer.files.length; ++i)
	{
		let File = ev.dataTransfer.files[i];
		let Name = File.name;
		let ExtMatch = Name.match(/\.[0-9a-zA-Z]+$/);
		let Ext = ExtMatch ? ExtMatch[0] : "";
		if(Ext.toLowerCase() == ".csv")
		{
			CsvCount++;
		}
		else if(Ext.toLowerCase() == ".mp4")
		{
			Mp4Count++;
		}
	}
	if(CsvCount == 0 && Mp4Count > 0)
	{
		//add to previous set.
		ReadMp4File(CSVSets[CSVSetNames[CSVSetNames.length-1]], ev.dataTransfer.files[0]);

	}
	else
	{
		let Set = CreateCSVSet();
		Set.PendingCount++;
		CSVSets[Set.Name] = Set;
		CSVSetNames.push(Set.Name);
		CSVNumSets++;
		for(let i = 0; i < ev.dataTransfer.files.length; ++i)
		{
			let File = ev.dataTransfer.files[i];
			let Name = File.name;
			let ExtMatch = Name.match(/\.[0-9a-zA-Z]+$/);
			let Ext = ExtMatch ? ExtMatch[0] : "";
			if(Ext.toLowerCase() == ".csv")
			{
				ReadCSVFile(Set, File);
			}
			else if(Ext.toLowerCase() == ".mp4")
			{
				if(!Set.Video)
				{
					ReadMp4File(Set, File);
				}
				else
				{
					if(!VideoAlert)
					{
						VideoAlert = true;
						window.alert("multiple Videos in one set not supported");
					}
				}
			}
			else
			{
				console.log("Not a .csv file!\n" + Name);
			}
		}
		if(0 == Set.PendingCount)
		{
			window.alert("No dropped CSV files. Please drop one or more csv files to use csv viewer");
		}
		Set.FinishedCount++;
		ParseCSVCheckFinished(Set.Name);
	}
  	ev.preventDefault();
}

function DragOverHandler(ev)
{
  ev.preventDefault();
}


ReadCookie();
ParseUrl();
ResizeCanvas();
SetupEvents();
InitMenu();
window.addEventListener("dragenter", WindowDragEnter);
window.addEventListener("dragleave", WindowDragLeave);
UpdateShowHelp(1);
RequestDraw();

</script>
</body>
</html>


